
---------------------------------------------------------------------------
operators :
-----------

what is an operator?
- an operator is a symbol which is used to perform some operations on operands.

- in c, there are total 47 operators.

- all the 47 operators are categorized into 3 categories

1. unary category

   - this category operators require single operand to perform operations.

     ex:
        ++  --  &  *  !  ~  sizeof  typecast etc

2. binary category

   - this category operators require two operands to perform operations.

     ex:
       + - * / % < > <= >= != == & | & && || etc

3. ternary category

   - this category operator requires three operands to perform operation.

     ex:
       ?: (conditional operator)


precendence and associativity of operators

precedence -> priority or preference

- using precedence we can find which operator should be given first priority or preference
  to evaluate.

associativity -> order (left to right or right to left)

- in which order an operator should be evaluated is nothing but associativity.

C-Operators Precedence Table
|- 47 operators (precedence and associativity)

BODMAS Rule
-----------
B - Brackets         ->  ()
O - Orders           ->  square, square root
D - Division         ->  /
M - Multiplication   ->  *
A - Addition         ->  +
S - Substraction     ->  -

ex-1:
  a = 5 + 3 * 9 / 2
                       
    = 5 + 3 * 4

    = 5 + 12
   
    = 17    (bodmas rule)


ex-2:
  a = 5 + 3 * 9 / 2

    = 5 + 27 / 2
              
    = 5 + 13
 
    = 18  (c-operators precedence table)


ex-3:
  a = 2 + 5; 

   left to right

    = 7

ex-4:
   a = 10;  //10 is assigned to a 
  
   right to left
  
ex-5:
   a = 2 + 5 + 4;

   left to right

     = 7 + 4

     = 11

---------------------------------------------------------------------------------------------
address of operator :  & (ampersand symbol)
-------------------
- it is a unary operator and it gives the address of a variable or memory location.

initialization : assigning or storing the value to a variable is called as initialization.

in 2 ways we can do initialization

1. compile time intialization

   - assigning the values to the variables in the program before compilation.

     ex:
       int a = 10;
       char ch = 'a';
       float b = 2.5;

2. runtime initialization

   - assigning the values to the variables at the time of running the program i.e., at runtime.

- we can do runtime initialization using scanf() function.

syntax:
  scanf("format specifiers",&arg-1,&arg-2,&arg-3.......&arg-n);

---------------------------------------------------------------------------------------
Arithmetic Operators :
--------------------
+ - * / %

Requirement-1: write a c-program to accept two numbers and swap two numbers using third variable.

Requirement-2: write a c-program to accept two numbers and swap two numbers without using third variable.

hint-1: + -

ex:
  int a = 5, b = 7;

  a = a + b;   //a = 12, b = 7

  b = a - b;   //a = 12, b = 5

  a = a - b;   //a = 7, b = 5

hint-2: * /
 
ex:
  int a = 5, b = 7;

  a = a * b;    //a = 35, b = 7

  b = a / b;    //a = 35, b = 5

  a = a / b;    //a = 7, b = 5  

Requirement: write a c-program to swap two numbers by writing single line logic.

hint: + - () =

ex:
  int a = 5, b = 7;

  a = (a + b) - (b = a);       or        a = (a + b) - (a = b);
  
parenthesis : ()
-----------
- it is used to control the precedence of operators.

case-1:
------
  int a;

  a = 4 * 3 + 2;

    = 12 + 2 

    = 14

case-2:
------
 int a;

 a = 4 * (3 + 2);

   = 4 * 5

   = 20


/ - division  :  it gives quotient after division.

% - modulus   :  it gives remainder after division.


5)7(1  (quotient)
 -5
 ---
  2   (remainder)


7/5 ->  1

7%5 ->  2

Requirement : write a c-program to accept a number and reverse that number.

hint: / %

------------------------------------------------------------------------------------------

5/2  =  2

5.0/2  =  2.5

5/2.0  =  2.5

5.0/2.0 = 2.5

2/5 = 0

2.0/5.0 = 0.4

-5/2  =  -2

5/-2  =  -2

-5/-2 =  2
-------------------------------------------------------------------------
47%5  =  2

-47%5 = -2

47%-5 = 2

-47%-5 = -2

47.0%5.0 = compile time error : illegal floating point 
-------------------------------------------------------------------------
relational operators :
--------------------
- these operators are used for checking the relation between the operands.

<  >  <=  >=  ==  !=

Note:
 - all relational operators return '1' if condition is true and return '0' if condition is false.

ex:
  int res;

  1. res = 2 < 4;   //1

  2. res = 2 > 4;   //0

  3. res = 5 <= 7;  //1

  4. res = 4 <= 2;  //0

  5. res = 3 <= 3;  //1

  6. res = 5 >= 2;  //1

  7. res = 5 >= 7;  //0

  8. res = 6 >= 9;  //0

  9. res = 4 == 4;  //1

  10. res = 5 != 4;  //1

  11. res = 10 == 10.0;   //1

  12. res = 'a' != 'b';  //1

-> nesting of relational operators is possible in c.

  13. res = 2 < 5 < 0;  //0

  14. res = 5 > 7 > 1;   //0

  15. res = 3 < 4 < 0 > 1;  //0

logical operators :
-----------------
&&  -   logical and
||  -   logical or
!   -   logical not

-----------------------------------
 a   b    a && b    a || b    !a  
-----------------------------------
 1   0      0         1       0
 1   1      1         1       0
 0   1      0         1       1
 0   0      0         0       1
-----------------------------------

note:
 - in c, every non-zero is considered as true and 0 is considered as false.

   non-zero number means -> 1, 2, 3, 4, 5,......


ex:
  int res;

1. res = 5 < 4 &&  7 > 3;   //0

2. res = 7 > 3 || 6 <= 3;   //1

3. res = 4 < 5 == 1 && 7 > 4 == 0;   //0

4. res = !4;  //0

5. res = !1 != 1;  //1


sizeof operator :
---------------
- it gives the size of the datatype or variable or constant.

syntax:
  n = sizeof(expression);

ex:
 1. int n;

    n = sizeof(int);  

    printf("%d",n);   //2

 2. int a = 10, n;

    n = sizeof(a);

    printf("%d",n);  //2

 3. int n;

    n = sizeof(5);

    printf("%d",n);  //2

 4. printf("%d",sizeof(float));   //4

 5. printf("%d",sizeof(2.5));     //8

 6. printf("%d",sizeof(2.5f));    //4

 7. printf("%d",sizeof(char));   //1

 8. printf("%d",sizeof('a'));    //2

 9. printf("%d",sizeof(void));   //c.e

-----------------------------------------------------------------------------------------------------------
conditional operator :    ?:
--------------------
- it is also called as ternary operator.

- using this operator we can write conditional statements.

syntax:
  condition/expression?expression-1:expression-2;

ex:
 1. 5<4?printf("hello"):printf("hi");   //hi

 2. int a = 7>3?100:200;   //a = 100

nested conditonal operator :
--------------------------

ex:
  int num = 111>222?333:444>555?666:777;

  printf("%d",num);  //777


assignment operator :   = 
-------------------
- it is used to assign a value to a variable.

- assignment operator can be used in 3 ways

1. simple assignment

   ex:
     int a;		(or)		int a = 10;

     a = 10;

2. chained assignment

   ex:
     int a,b,c,d;

     a = b = c = d = 100;

3. compound assignment

   ex:
     a = a + b;   ->   a += b;

     x = x * y;   ->   x *= y;

     c = a + b;   //we cannot compound assignment here

+= -= *= /= %= &= |= ^= <<= >==

comma operator   ,
--------------
- it is used to separate values and variables.

ex:
  1. int a;   ->   int a,b,c;
     int b;
     int c;

  2. int arr[5] = {1, 2, 3, 4, 5};

  3. int n;

     n = 5, 1, 9, 4;    //error

     printf("%d",n);

  
     n = (5, 1, 9, 4);    

     printf("%d",n);   //4

type means datatype

casting means conversion

type casting :
------------
- it is a process of converting one datatype to another datatype.

- there are 2 types of type casting

  1. implicit type casting

     - the type casting which is performed by compiler automatically.

       ex:
         float a = 10;   //10.0

         int num = 'a';   //97

  2. explicit type casting

     - the type casting which is performed by programmer manually.

       ex:
        int a = 5.6;   //5

float a;

a = (float)7/2;

printf("%f",a);  //3.5

Java 
----
1. J2SE  (JSE)  -  Java Standard Edition    (Core Java)    

2. J2EE  (JEE)  -  Java Enterprise Edition  (Advance Java)


3. J2ME  (JME)  -  Java Micro Edition



What is Java?

- Java is a programming language.

- Java is a high level language.

- Java is called as object oriented programming language.

what is object oriented programming?

- object oriented programming is a programming paradigm.

- a programming paradigm is called as programming methodology.

- object oriented programming paradigm has set of principles.

  i. class and object
  ii. data hiding
  iii. encapsulation
  iv. abstraction
  v. inheritance (is-a relationship)
  vi. composition (has-a relationship)
  vii. polymorphism

- as java supports or obeys all the principles of object oriented programming paradigm
  thats why java is called as object oriented programming language.


Java 
|- Technology         -       Sun Micro System
   |- Open Source 

- Every technology has API, so java technology also has API.

What is api?

- api stands for application programming interface.

- a group of predefined classes and interfaces which are developed and provided by
  sun micro system in java is called as api.

- api means classes and interfaces

- using api (classes and interfaces) we develop java programs which becomes software 
  or application.

-------------------------------------------------------------------------------------
- in c, all predefined functions represent api.

- all predefined functions are coming from header files (c-library).
-------------------------------------------------------------------------------------

- Generally there are 2 types of api

1. public api 

  - it is an open source.

    ex: java api

2. propriotery api

  - it is commercial and secret.
 
    ex: windows api

--------------------------------------------------------------------------------------------
- If we want to use java then we have to download JDK software and install.

JDK
|- JRE
   |- JVM
   |- Class Libraries
|- Development Tools

- In Java Everything is open source except JVM.

Who has to pay for jvm and when they have to pay for jvm?
--------------------------------------------------------------------------------

History Of Java :
---------------

90's decade -> early 90's -> sun micro system 

- employees -> james gosling, mike sheradin, patrick naugton etc

- business client -> requirements -> project -> digital devices (ex: set top box, televisions etc)

- stealth project -> green project -> green team 

- language -> c and c++ (platform dependent)

- developing a language which is platform independent

R & D -> AT & T laboratory (Bell Labs) 

restaurant -> coffee

silk, dynamic etc

Oak

Java  -> 23 jan 1996 -> jdk 1.0 (stable)

java soft people

Features Of Java : (Java Buzzwords)
----------------
1. simple
2. object oriented 
3. robust
4. platform independent
5. portable
6. architectural neutral
7. secure
8. multi-threaded
9. distributed
10. high performance
11. dynamic


1. simple :
   ------
- java follows the same syntaxes of c and c++ languages which makes learning java simple.

- pointers, goto statement and multiple inheritance are the concepts which are available
  in c & c++ languages which can make programmer confuse easily, so sun micro system has 
  removed pointers, goto statement and multiple inheritance from java to make java as
  simple.

2. object oriented :
   ---------------
what is object oriented?
- object oriented is a programming paradigm or a programming methodology which has set
  of principles.

  principles 
  ----------
  i. class and object
  ii. data hiding
  iii. abstraction
  iv. encapsulatuion
  v. inheritance (is-a relationship)
  vi. composition (has-a relationship)
  vii. polymorphism

- as java obeys or supports all the principles of object oriented programming paradigm
  thats why java is called as object oriented.


what is a class?

- anything which does not exist physically which is just our imaginations or our thoughts
  about an object and which will not occupy any memory or space is nothing but a class. 

- a class is a plan or a blueprint which represents the structure of an object.

- a class is a blueprint for creating an object.

- a class is a logical form of an object.

- a class represents a group name for collection of similar objects.

  ex:
    1. car, bike, bus, train     ->     Vehicle

    2. apple, orange, grapes     ->     Fruit

    3. tiger, lion, rhino, hippo ->     Animal

    4. ravi, ali, susan, smith   ->     Person

what is an object?

- anything which exists physically in this real world and which will occupy memory or space
  can be considered as an object.

- an object is the physical form of a class or an object is called as an instance (physical 
  form) of a class.

- creating a class in java is nothing but creating a userdefined datatype and class name becomes userdefined datatype 
  name.

note:
 - we can always create a class without creating an object but we cannot create object 
   without creating a class.

 - to create object class is mandatory but to create class object is not mandatory.

 - the aim of creating a class is to create an object.

3. robust :
   ------
- robust means strong

- java is robust means strong.

i. java has better memory management
ii. java has better exception handling mechanism

memory management : allocating and deallocating the memory is called as memory management.

there are 2 types of memory management

1. static memory allocation

- allocating the memory at the time of compilation is called as static memory allocation.

ex:
  int a;
  int a[5];
  etc

2. dynamic memory allocation

- allocating the memory at runtime dynamically is caleld as dynamic memory allocation.

 ex:
   malloc(), realloc(), calloc(), free()  ->  dynamic memory allocation functions

- java has better memory management because in java programmer is responsible to allocate
  the memory and programmer is not responsible for deallocating the memory which is taken
  care by garbage collector automatically.

- in java, sun micro system has provided a rich set of api classes and interfaces to work
  with exception handling which makes exception handling mechanism better.


4. platform independent
   --------------------
- once we compile a .java file, java compiler converts into .class file with byte code 
  and .class file is not specific to any platform it is platform independent we can carry
  on any operating system and the byte code which is there .class file is specific to jvm
  means only jvm can understand and execute the byte code so we can carry .class file with
  byte code on any machine with any operating system and any processor this is called as
  platform independent.

5. architectural neutral 
   ---------------------
- architecture means micro processor

- when we compile a java program, java compiler converts source code into byte code which
  is not specific to any micro processor so we can execute the byte code on any micro processor
  irrespective of their vendor this is called architectural neutral.

6. portable 
   --------
- java supports developing different types of applications and which can run on different
  machines or devices and networks thats why java is called as portable.

  ex: standalone applications -> client machine
      mobile applications -> mobile devices
      enterprise web applications -> networks

7. multi-threaded 
   --------------
- java is multi-threaded because in java, sun micro system has given a rich set of api
  classes and interfaces to develop multi-threaded applications easily.

8. distributed 
   -----------
- In java, sun micro system has provided several distributed technologies (corba, rmi, ejb etc)
  to develop distributed applications thats why java is called as distributed.

9. secure 
   ------
- java is a secure language.

  i. java will not allow to create pointers

  ii. byte code is executed inside the jvm where byte code verification will be done before executing the 
      byte code.

10. high performance 
    ----------------
- java is high performance because in java along with interpreter JIT Compiler is there to execute the
  byte code.

11. dynamic 
    -------
- java supports dynamic memory allocation using new operator.

- classes will be loaded dynamically at runtime by the classloaders.


---------------------------------------------------------------------------------------
writing first java program :
--------------------------

company -> IDE (Integrated Development Environment) - software tool

java ide's : eclipse, myeclipse, netbeans, jdeveloper, rsa, sts etc

editors: notepad, notepad++, editplus, wordpad etc


---------------------------------------------------------------------------------
comments :
--------
- comments are non-executable statements present in a program.

- comments are for providing documentation in a program.

- comments make program more readable and easily understandable.

- there are 3 types of comments in java

  1. single line comments

     syntax:
        //this is single line comment

  2. multi line comments

     syntax:
       /*
          this is multi line comment
       */

  3. documentation comments

     syntax:
       /**
          write some text
       */

---------------------------------------------------------------------------

how to create a class?

syntax:
  access-modifier class ClassName
  {
     //members (variables and methods)
  }

- here access modifier and members are optional.

Note:
 - class name and the file name must be same.

 - String and System are predefined api classes in java.

 - Sun Micro Systems has placed String and System classes inside java.lang package.

 - to use String class we have to use java.lang.String and to use System class
   we have to use java.lang.System.
 
 - we can avoid using fully qualified name by using import.

 - import is a keyword in java and it is used to import the classes of a package
   in a java program.

 - if we dont import java.lang package then also java program will work because
   java.lang is the default package which imported by java compiler automatically.

 - to compile a java program we use javac command which is called as java compiler
 
   syntax:
       javac ClassName.java [Enter]

 - to run a java program we use java command which is called as jvm.

   syntax:
       java ClassName [Enter]

-----------------------------------------------------------------------------------------
main method in java 
-------------------
  public static void main(String args[])

public :
------
 - it is a modifier (access modifier) and it used to specify the scope of a method.
 - if we declare any method using public modifier then any one from any where can
   access that method.
 - jvm calls main method so it must be visible and accessible to jvm thats why it
   is public.
 - always jvm looks for main method as public only.

static :
------
 - it is a modifier (non-access modifier) and it used to give special instruction to
   compiler and jvm.
 - if we declare a method of a class using static then compiler and jvm allow to call
   that method without creating the object, using class name directly.
 - jvm internally calls main method without creating the object, using class name 
   directly.
 - always jvm looks for main method as static.

void :
----
 - it is a datatype which represents empty.
 - main method return type is void which means main method will not return any value.
 - always jvm looks for main method return type as void only.

String args[] :
-------------
- main method has a parameter whose name is args and whose type is String[].
- main method uses args parameter to receive command line arguments.
- always jvm looks for main method parameter whose type must be String[].

note:
 - always jvm looks for main method as public static void main(String args[]).

modifiers :
---------
- all modifiers are keywords but every keyword is not a modifier.

- modifiers are used to give some instructions to compiler and jvm based on which 
  compiler and jvm perform some action.

ex:
  public, private, protected, default, final, static, abstract, synchronized, 
  transient, strictfp, volatile, native

- there are 2 types of modifiers

  1. access modifiers

     ex: public, private, protected, default 

  2. non-access modifiers
  
     ex: final, static, abstract, synchronized, transient, strictfp, volatile, native


- using access modifier we can specify the scope of a variable or a method or a class etc.

- using access modifier we are giving instructions to compiler and jvm regarding scope.

class A
{
   private int i = 10;
   public int j = 20;
}


- using non-access modifiers we can give special instructions to compiler and jvm.

final int a = 10;

a = 20;  //c.e

class A
{
   void m1() {
   }
}

- to call a method of a class object is mandatory.

  A obj = new A();
  obj.m1();

- if we want to tell compiler and jvm to call a method of a class without creating the
  object using class name directly then declare the method as static.
  
  syntax:
    ClassName.methodName();

class A
{
   static void m1() {
   }
}

A.m1();

string concatenation operator :  plus symbol +
-----------------------------
- if atleast one of the operand is string type then + acts as string concatenation operator.

- the result of string concatenation is always a string.

ex:
 1. "hello" + 10 = "hello10"

 2. 10 + "hello" = "10hello"

 3. "hello" + "bye" = "hellobye"

------------------------------------------------------------------------------------------------
java naming conventions :
-----------------------
- java naming conventions are the rules given by sun micro system for writing any name in java.

1. naming conventions for class names and interface names

ex:
  String, System, Date, Calendar, Runnable, Connection, StringBuffer, BufferedReader, ResultSet,
  PreparedStatement, ObjectInputStream, InputStreamReader, Employee, Student, TicketReservation etc

2. naming conventions for method names
  
ex:
  read(), close(), equals(), substring(), readLine(), nextInt(), equalsIgnoreCase(), charAt(),
  compareToIngoreCase(), add(), work(), performTask(), getSalary() etc

3. naming conventions for variable names

ex:
  id, age, city, state, country, zipCode, firstName, lastName, dateOfBirth, length etc

4. naming conventions for constants variable names

ex:
  PI, NUM, MONTH, YEAR, AM, AM_PM, MAX_PRIORITY, MIN_PRIORITY, NORM_PRIORIY, DAY_OF_MONTH etc

5. naming conventions for package names

ex:
  java.lang, java.util, java.io, java.sql, javax.sql, javax.servlet, javax.servlet.http etc

6. naming conventsion for keywords

ex:
 class, import, final, static, public, private, protected, default, switch, for, do, white etc

---------------------------------------------------------------------------------------------------
identifier :
----------
- any name in java is called as identifier.

ex:
  class name, interface name, method name, variable name etc

rules for identifiers :
---------------------
1. a to z
   A to Z
   0 to 9
   _
   $

2. an identifier cannot be started with a digit.

3. an identifier can start with any alphabet or underscore only.

4. special characters are not allowed except dollar and underscore.

5. there is no length limit for identifier.

6. keywords cannot be used as identifiers.

7. identifiers are case sensitive.

8. all predefined class names and interface names can be used as identifier, it is valid but
   not recommended to use.

ex:
  _abc123    //valid

  abc123     //valid

  Num123     //valid

  4abc       //invalid

  _$_$       //valid

  $abc123    //invalid

  abc@123    //invalid

  switch     //invalid

keywords :
--------
- java has grammar and the grammar of java is represented by english words which are reserved or
  fixed in java where every word has a special meaning which is known to java compiler such words
  are called as keywords.

- in short, keywords represent grammar of java.

- java provides set of instructions using which we develop java programs such instructions are also
  called as keywords.

- there are total 51 keywords are there in java out of which 49 keywords are in use and 2 keywords
  are not in use.

- keywords which are in use :
     ex:
      for, while, do, switch, if, else, case, default, public, private, protected, break, continue,
      return, final, transient, abstract, synchronized, instanceof, strictfp, volatile, native,  
      class, import, package, implements, extends, interface, new etc

- keywords which are not in use :
  ex:
    goto, const

literals (constants)
--------
ex:
  int a = 10;

- int is datatype/keyword
- a is variable/identifier
- 10 is a fixed value/literal

what is a literal?
- a fixed value which can be assigned to a variable is called as literal (constant).

decimal literals :
----------------
base  -   10
range -   0 to 9

ex:
  int a = 3;
  int a = 6;
  int a = 9;
  int a = 99;
  int a = 1000;
  int a = 34567;

Note:
 - By default every integer number is int type, to represent an integer number as long type we have
   to use l or L letter as suffix. 

octal literals :
--------------
base   -    8
range  -    0 to 7
prefix -    0

ex:
  int a = 01;
  int a = 07; 
  int a = 010;
  int a = 045;
  int a = 0421;

hexadecimal literals :
--------------------
base    -  16
range   -  0 to 15 (0 to 9 a b c d e f)
prefix  -  0x or 0X

ex:
  int num = 0x10;
  int num = 0xa;
  int num = 0x4e;
  int num = 0x5fD2;
  
binary literals :
---------------
base    -    2
range   -    0 and 1
prefix  -    0b or 0B

ex:
  int num = 0b1010;   //10
  int num = 0B1111;   //15
  int num = 0b0111;   //7
  int num = 0b10010;  //18

floating literals :
-----------------
Note:
 - By default every floating number is double type, to represent a floating number as float type we
   have to use f or F letter as suffix.

ex:
  float a = 2.5;   //c.e

  float a = 2.5f;

  double a = 4.5;

  float a = 10;   //10.0

  float a = 011;  //9.0

  float a = 0x10;   //16.0

  float a = 0b1010;  //10.0

  double a = 13e3;  //13000.0

  float a = 5e2;   //c.e: because exponential result is always double type

  double a = 5E2;  //500.0

character literals :
------------------
- a single alphabet or a single digit or a single special character or a single white space charater
  which is enclosed (written) within single quotations is called as character literal.

ex:
  char ch = 'a';

  char ch = '5';

  char ch = '@';

  char ch = ' ';

  char ch = 'ab';  //invalid

  char ch = '10';  //invalid

Note:
 - All escape sequence characters can be used as character literals.

  char ch = '\n';
 
  char ch = '\"';

  char ch = '\t';

  char ch = '\x';   //invalid

  char ch = 97;  //a

Note:
 - To represent unicode values in java sun micro system has provided unicode literal '\uxxxx'
   where each x can be any hexadecimal value.

  char ch = '\u0061';  //a

string literals :
---------------
- a group of characters which are enclosed (written) within double quotations is called as string or
  string literal.

ex:
  String str = "hyderabad";

  String str = "ravi kumar";
 
  String str = "hello";

  String str = "abc123!@#";

boolean literals :
----------------
- true and false are called as boolean literals.

ex:
  boolean b = true;

  boolean b = false;

  boolean b = 1;  //c.e

  boolean b = 0;  //c.e

  boolean b = True;   //c.e

- boolean literals are case sensitive.

datatypes :
---------
- datatypes are the keywords and they are used to specify 2 things

  1. type of data
  2. size of data

- datatypes are used to specify what type of data a variable should hold.

- datatypes are also used to specify how much memory should be allocated to store the data.

- datatypes are categorized into 2 types

  1. primitive datatypes

     ex: byte, short, int, long, float, double, char, boolean, void

  2. userdefined datatypes

     ex: any class

primitive datatypes :
-------------------
1. integer datatypes
   
   ex: byte, short, int, long

2. floating datatypes

   ex: float, double
  
3. character datatype

   ex: char

4. boolean datatype

   ex: boolean

5. void datatype

   ex: void

operators in java :
-----------------
what is an operator?

- an operator is a symbol which is used to perform some operations on operands (variables).

ex:
  int a = 10, b = 20;

  a + b

here + symbol is an operator, a and b are operands

- operators precedence table in java
  |- 40 operators 
     |- precedence and associativity

new operator :
------------
- new operator is used to create object to a class, creating object to a class means allocating the
  memory for the members of the class and once the memory is allocated we can access or use those
  members using object.

syntax:
  ClassName objName = new ClassName(); 

----------------------------------------------------------------------------------
java.lang
|- Object : it is the super class for every class in java.
   
Object
|- int hashCode() : it returns object hashcode number (object reference number).

class A     //super class
{
  void m1(){
  }
}

class B extends A   //sub class
{
   void m2(){
   }
}

B b = new B();
b.m2();
b.m1();

member operator : . dot sybmol
---------------
- member operator is used to access or refer to the members of a class or an object.

i. member operator is used to access or refer to instance variables of an class.

   syntax:
     objName.variableName;

ii. member operator is used to access or refer to instance methods of a class.

   syntax:
      objName.methodName();

iii. member operator is used to access or refer to static variables of a class.

   syntax:
      ClassName.variableName;   //recommended

             (or)
 
      objName.variableName;

iv. member operator is used to access or refer to static methods of a class.

    syntax:
       ClassName.methodName();   //recommended

               (or)

       objName.methodName();

increment and decrement operators :  ++ and --
---------------------------------
++ is called as increment operator

-- is called as decrement operator

- these operators are unary operators.

Note:

- increment operator increments the value of a variable by '1' directly in the memory location.

- decrement operator decrements the value of a variable by '1' directly in the memory location.

arithmetic operators :
--------------------
+  addition
-  substraction
*  multiplication
/  division
%  modulus

ex:
  byte a = 10;
  byte b = 20;

  byte c = a + b;
  System.out.println(c);   //30

Note:
 - Whenever we perform any arithmetic operations on any operands in java, we must have to follow 
   a rule :

         MAX(int, type of first operand, type of second operand)

ex:
  byte + byte = int
  char + byte = int
  char + char = int
  short + byte = int
  byte + long = long
  short + float = float
  int + float = float
  int + double = double
  long + float = float
  float + double = double
  byte * short = int
  short - int = int
  int / short = int
  byte % byte = int

relational operators :
--------------------
<   less than
>   greater than
<=  less than equal
>=  greater than equal

Note:
 - All relational operators return "true" if condition is satisfied or else return "false" if 
   condition is not satisfied.

 ex:
   boolean res;

   1. res = 2 < 5;   //true

   2. res = 2 > 5;   //false

   3. res = 5 <= 4;   //false

   4. res = 5 <= 5;   //true

   5. res = 3 <= 5;   //true

   7. res = 7 >= 4;   //true

   8. res = 7 >= 9;   //false

   9. res = 7 >= 7;   //true
  
   10. res = 5.5 <= 6.5;  //true

   11. res = 'a' < 'b';  //true

   12. res = true >= false;   //c.e: bad operand types

Note:
 - All relational operators can be applied on all the primitive datatypes except boolean.

   13. String s1 = "hello";
       String s2 = "welcome";

       System.out.println(s1 <= s2);  //c.e: bad operand types

Note:
 - We cannot apply relational operators on objects.
   
equality operators : 
------------------
==   double equal
!=   not equal

Note:
 - All equality operators return "true" if condition is satisfied or else return "false" if 
   condition is not satisfied.

ex:
  boolean res;

  1. res = 5 == 5;    //true

  2. res = 5 != 5;    //false

  3. res = 10 == 10.0;   //true

  4. res = 'a' != 'b';  //true

  5. res = true != false;   //true

Note:
 - We can apply equality operators on all the primitive datatypes including boolean.

  6. String s1 = "hello";
     String s2 = "welcome";

     System.out.println(s1 == s2);
     System.out.println(s1 != s2);

Note:
 - We can also apply equality operators on objects and if we apply equality operators on objects then
   equality operators compare object reference numbers.

 - We can compare two different class objects using equality operators only when there is inheritance
   relationship between the classes.

instanceof operator :
-------------------
- it is used to test whether an object is an instance of which class type or interface
  type.

syntax:
   boolean res = objName instanceof ClassName/InterfaceName;

class Employee    (Employee type)
{
}

class Student     (Student type)
{
}

Employee e = new Employee();

e -> it is an object which is an instance of Employee class or Employee type

Student s = new Student();

s-> it is an object which is an instance of Student class or Student type

Note:
 - We cannot use instanceof operator to test two different class types directly without
   having inheritance relationship.

 - We can use instanceof operator to test two different class types only when there is
   inheritance relationship between the class.



class A         //A type                  super class or parent class
{
   void m1() {
   }
}

class B extends A      //B type, A type          sub class or child class
{
  void m2() {
  }
}

Note:
 - Every sub class is not only sub class type but also super class type because a sub 
   class has both sub class and super class properties.

--------------------------------------------------------------------------------------
what is type casting?

- it is a process of converting one datatype to another datatype.

there are 2 types of type casting

1. implicit type casting

   - the type casting which is performed by java compiler automatically.

     ex:
       float a = 10;   //10.0                   -  widening or upcasting

       int num = 'a';  //97

2. explicit type casting

   - the type casting which is performed by programmer manually.

     ex:
       int a = (int)5.2;                        -   narrowing or downcasting 
       System.out.println(a);  //5 


what is widening or upcasting?

- the process of converting a lower datatype to a higher datatype is called as upcasting
  or widening.

what is narrowing or downcasting?

- the process of converting a higher datatype to a lower datatype is called as narrowing
  or downcasting.

type cast operator :
------------------
- it is used to perform explicit type casting.

syntax:
  (type)

type casting with respect to userdefined datatypes :
--------------------------------------------------
ex:
 class One                 //One type    (super or parent class)
 {
    void methodOne() {
    }
 }

 class Two extends One      //Two type    (sub or child class)
 {
    void methodTwo() {
    }
 }

 One o = new Two();          -  upcasting or widening

 o.methodOne();   //valid
 o.methodTwo();   //invalid (compile time error)

 Two t = (Two)o;          -   narrowing or downcasting
 
 t.methodOne();  //valid
 t.methodTwo();  //valid

Note:
  - Using super class reference variable we can access only super class members but not
    sub class members.

  - To access both super class and sub class members we need sub class reference variable.


 Two t = new Two();    //valid 

 One o = new Two();     //valid

 One o = new One();     //valid

 Two t = new One();     //invalid

--------------------------------------------------------------------------------------
assignment operator :  = equal to symbol
-------------------
- it is used to assign a value to a variable.

- assignment operator can be used in 3 ways

  i. simple assignment

     ex:
      int a;			(or)		int a = 10;

      a = 10;

  ii. chained assignment

      ex:
       int a,b,c,d;

       a = b = c = d = 100;

   iii. compound assignment

        ex:
          a = a + b;    ->    a += b;

          x = x - y;    ->    x -= y;

          a = a * b;    ->    a *= b;

          c = a + b;    ->    we cannot use compound assignment in this case
parenthesis ()
-----------
- it is the highest precedence operator in java and it is used to control the precedence
  of other operators.

  ex: without parenthesis

      int a;

      a = 5 * 3 + 4;

      a = 19

   ex: with parenthesis

       int a;

       a = 5 * (3 + 4);

       a = 35


bitwise operators :
-----------------
- bitwise operators work internally on bits i.e., 0's and 1's.

&   -  bitwise and
|   -  bitwise or
^   -  bitwise xor
~   -  bitwise complement
<<  -  bitwise left shift
>>  -  bitwise right shift
>>> -  bitwise zero fill right shift

---> &, |, ^ operators can be applied on integer and boolean types and they are binary operators.

ex:
  1. boolean b1 = true, b2 = false;

     System.out.println(b1 & b2);   //false
     System.out.println(b1 | b2);   //true
     System.out.println(b1 ^ b2);   //true

  2. int a = 10, b = 6;

     System.out.println(a & b);    //2

     
     1010
     0110  &
    ------ 
     0010  =  2
    ------

  3. int a = 10, b = 6;

     System.out.println(a | b);   //14

     1010
     0110  |  
    ------
     1110   =  14
    ------

  4. int a = 10, b = 6;

     System.out.println(a ^ b);   //12

     1010
     0110  ^
    ------
     1100    =    12
    ------

bitwise complement  ~
------------------
- it is a unary operator and it is applied only on integer types.

ex:
  int a = 5;

  System.out.println(~a);   //-6

  0000 0101   (binary of +5 in 8 bits)

    ~a

  1111 1010   (binary of -6 in 8 bits)

- to find the value of -ve binary number take the bits which are representing value

  111 1010

  find 2's complement

        1
  000 0101   (1's complement)
    +    1
  --------
  000 0110    (2's complement)
  --------
 
  000 0110  ->   6  ->   -6

note:
  - for bitwise complement these is a formulat -(n+1).

    ex:
      int a = 5;

      System.out.println(~a);           -(5+1)  ->  -6


bitwise left shift   <<
------------------
- it is a binary operator and it is applied only on integer types.

- it shifts the specified bits towards left.

ex:
  int a = 10;

  System.out.println(a << 1);   //20

  
  0000 1010   (binary of +10 in 8 bits)

   a << 1

  _000 1010

  - to fill the vacant position all the bits start shifting towards left.

  0001 010_

  - at right hand side the position becomes vacant which is automatically filled with '0'.

  0001 0100  =   20

note:
 - bitwise left shift operator works like multiplication operator.

bitwise right shift   >>
-------------------
- it is a binary operator and it is applied only on integer types.

- it shifts the specified bits towards right.

ex:
   int a = 10;

   System.out.println(a >> 1);   //5

   0000 1010  (binary of +10 in 8 bits)

     a >> 1

   0000 101_

   - to fill the vacant position all the bits start shifting towards right.

   _000 0101

   - at left hand side the position becomes vacant which is automatically filled with either 0 or 1.

   0000 0101  =   5

note:
  - bitwise right shift operator works like division operator.


bitwise zero fill right shift operator   >>>
--------------------------------------
- it is same as bitwise right shift operator except one difference i.e., in case of bitwise right
  shift operator if the number is positive then sign bit (msb) is filled with '0' and if the number
  is negative then the sign bit (msb) is filled with '1' but in case of bitwise zero fill right shift
  operator always the sign bit (msb) is filled with '0' whether the number is positive or negative so
  the result is always positive. 


boolean complement operator   !
---------------------------
- it is a unary operator and it is applied only on boolean type.

ex:
  1. boolean a = true;

     System.out.println(!a);   //false

  2. boolean a = false;

     System.out.println(!a);   //true

  3. System.out.println(!(2 < 5));   //false

  4. System.out.println(!(5 > 4 == 7 < 9));   //false


short circuit operators :
-----------------------
&&  -  logical and
||  -  logical or

---> short circuit operators are same as bitwise and, bitwise or operators except few differences.

 ----------------------------------------------------------------------------------------------------
        &, |    (bitwise and, bitwise or)                   &&, || (short circuit)
 ---------------------------------------------------------------------------------------------------
 1. these operators can be applied on integer       1. these operators can be applied only on boolean
    and boolean types.                                 types.


 2. second expression evalulation is always         2. second expression evaluation is not always man-
    mandatory whether first expression is true         datory sometimes it is optional.
    or false.                                        
                                                       i. in case of && if first expression is false
                                                          then only second expression evaluation is 
                                                          optional otherwise mandatory.

                                                       ii. in case of || if first expression is true
                                                           then only second expression evaluation is
                                                           optional otherwise mandatory.
------------------------------------------------------------------------------------------------------

Note:
  - it is recommended to use short circuit operators over bitwise and, bitwise or operators because
    short circuit operators improve performance.



conditional operator  ?:
--------------------
- it is also called as ternary operator.

- using this operator we can write conditional statement.

syntax:
   condition/expression?expression-1:expression-2;

Control Flow Statements (Control Structures)
-----------------------
- Control flow statements are the statements which are used to specify the order in which a program
  is executed at runtime.

- control flow statements are categorized into 3 types

  1. selection statements

     ex:
       if statement or simple if
       if else statement
       else if ladder
       switch case

  2. iterative statements

     ex:
       while
       do while
       for 
       for each

  3. transfer statements
   
     ex:
       break
       continue
       return

if statement (simple if)
------------
syntax:
  if(condition/expression)           //here condition or expression must be boolean type
    statement;

- for if statement body is optional.

- if we dont write body for if statement then if condition is applied only for 1 statement.

- if we want to apply if condition for more than 1 statement then write body.

ex:
 1. if(2<5)
      System.out.println("hello");    //hello

 2. if(2>5)
      System.out.println("hello");

 3. if(2>5)
      System.out.println("hello");    //hi
      System.out.println("hi");

 4. if(2<5)
      System.out.println("hello");    //hello hi
      System.out.println("hi");      

 5. if(2>5)
     System.out.println("hello");     //hi bye 
     System.out.println("hi");
     System.out.println("bye");

 6. if(2>5)
    {
      System.out.println("hello");        //bye
      System.out.println("hi");
    } 
     System.out.println("bye");

program: write a java program to check a number is even or odd.

program: write a java program to take an amount and check if amount is greater than or equal to 5000
         then 10% discount.

nested if :
---------
- if inside if is called as nested if.

syntax:
  if(condition-1/expression-1)
  {
     if(condition-2/expression-2)
     {
         if(condition-3/expression-3)
         {
          .
          .
          .
         }
     }
  }

ex:
  int a = 3, b = 5, c = 2;

  if(a == 3)
  {
     if(b == 5)
     {
        if(c == 2)
          System.out.println("hello");

        System.out.println("hi");
     }
     System.out.println("welcome");
  }

  System.out.println("bye");


hello
hi
welcome
bye

if else statement :
-----------------
syntax:
  if(condition/expression)
    statement-1;
  else
    statement-2;

- here condition/expression must be boolean type.

- for if else statement body is optional and if we dont write body then if and else both are applied
  for 1 statement only.

- if we want to apply if and else for more than 1 statement then we must have to write body.

- if never demands else but else always demands if, in simple if can exist without else but else 
  cannot exist without if.

ex:
  1. if(2<5)
       System.out.println("hello");       //hello
     else
       System.out.println("hi");

  2. if(2>5)
       System.out.println("hello");    //hi
     else
       System.out.println("hi");

  3. if(2<5)
       System.out.println("hi");              //hi welcome
     else
       System.out.println("hello");
       System.out.println("welcome");

  4. if(2>5)
       System.out.println("hi");            //hello welcome
     else
       System.out.println("hello");
       System.out.println("welcome");

  5. if(2<5)
       System.out.println("hi");                 
       System.out.println("hello");
     else                                   //c.e: else without if
       System.out.println("welcome");

  6. if(2<5)
     {
       System.out.println("hi");                 
       System.out.println("hello");
     }
     else                                     //hi hello
       System.out.println("welcome");

  7. if(2>5)
     {
       System.out.println("hi");                 
       System.out.println("hello");
     }
     else   
     {                                
       System.out.println("welcome");
       System.out.println("how are you");
     }
      System.out.println("bye");

  8. if(2<5)
     {
       System.out.println("hi");                 
       System.out.println("hello");
     }
      System.out.println("done");      
     else                    //c.e: else without if
     {                                
       System.out.println("welcome");
       System.out.println("how are you");
     }

program: write a java program to check a person is eligible to vote or not.

program: write a java program to take an amount and check if amount is greater than or equal to 
         10 thousand give 20% discount or else 5% discount.

nested if else :
--------------
- if else inside another if else is called as nested if else.

syntax:
  if(condition-1)
  {
      if(condition-2)
        statement-1;
      else
        statement-2;
     statement-3;
  }
  else
  {
      if(condition-3)
        statement-4;
      else
        statement-5;
     statement-6;
  }

program: write a program to find the biggest of 3 numbers.

if else ladder :
--------------
syntax:
   if(condition-1)
     statement-1;
   else if(condition-2)
     statement-2;
   else if(condition-3)
     statement-3;
   .
   .
   .
   else if(condition-n)
      statement-n;
   else
     default-statement;

program: write a java program to take 3 subject marks, find total, average and result.

i. if average greater than or equal to 75  -  first class with distinction
ii. if average less than 75 and greater than equal to 65  -   first class
iii. if average less than 65 and greater than equal to 55  -  second class
iv. if average less than 55 and greater than equal to 45  -  third class
v. if average less than 45 - failed

switch case :
-----------
syntax:
  switch(expression)
  {
    case label-1: statement(s);
    break;
    case label-2: statement(s);
    break; 
    case label-3: statement(s);
   
    .
    .
    .
    .
    case label-n: statement(s);
    break;
    default: default-statement(s);
  }
 

Note:
 i. the types which are allowed for switch expression are : byte, short, int, char, String, wrapper 
                                                            classes, enum)

 ii. the types which are allowed for switch expression same types are allowed for labels.

 iii. switch expression can be a constant or variable expression but label must be constant expression.

 iv. cases are optional.

 v. switch expression is mandatory.

 vi. duplicate cases are not allowed.

 vii. order of cases is not mandatory.

 viii. break is optional in switch case.


while loop :
----------
syntax:
  while(condition/expression)            //here condition or expression must be boolean type
  {
     statement(s);
  }

- every loop has 5 sections

  1. initialization
  2. condition
  3. execution
  4. updation
  5. termination

- loops are categorized into 2 types

  1. pre-tested loops 
     
     ex: while, for, for each

  2. post-tested loops
  
     ex: do while

program-1: write a java program to find the sum of 100 numbers.

program-2: write a java program to display all the even numbers between 1 to 100.
--------------------------------------------------------------------------------------------------
program-3: write a java program to reverse a number.

do while loop :
-------------
syntax:
  do
  {
     statement(s);
  }
  while(condition/expression);

program-1: write a java program to display multiplication table of a number.

5 x 1 = 5
5 x 2 = 10
.
.
.
.
5 x 10 = 50

program-2: write a java program to display fibonacci series upto 20.

0   1   1   2   3   5   8   13   21   34 ...............
f1  f2  f3
    f1  f2  f3
        f1  f2  f3
             .   .  .

for loop :
--------
syntax:
   for(initialization;condition;updation)
     statement;
     
program-1: write a java program to find the factorial of a number.

program-2: write a java program to test whether a number is prime or not.

prime number -> a number which is divisible by 1 and itself only.

4  ->  1, 2, 4  not prime

7  ->  1, 7   prime 

program-3: write a java program to check whether a number is armstrong or not.




153 -> 1 cube + 5 cube + 3 cube = 153

java.lang
|- Math
   |- public static double pow(double a, double b)

ex:
  double res = Math.pow(9, 2);
  System.out.println(res);   //81.0

nested loops :
------------
- loop inside another loop is called as nested loop.

- whenever if we have any output in the form of one to many then use nested loops.


c1 c2 c3 c4 c5 
                   
1  2  3  4  5      r1    
1  2  3  4  5      r2
1  2  3  4  5      r3
1  2  3  4  5      r4
1  2  3  4  5      r5

each row has 5 columns
    1        many

1st loop (outer loop) -> for representing rows

2nd loop (inner loop) -> for representing columns

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=5;j++)
   {
      System.out.print(j + "   ");
   }

   System.out.println();
}

when i is 1 then j should be 1,2,3,4,5

when i is 2 then j should be 1,2,3,4,5

when i is 3 then j should be 1,2,3,4,5

when i is 4 then j should be 1,2,3,4,5

when i is 5 then j should be 1,2,3,4,5

--------------------------------------------------------------
1  1  1  1  1
2  2  2  2  2
3  3  3  3  3
4  4  4  4  4
5  5  5  5  5

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=5;j++)
   {
      System.out.print(i + "   ");
   }

   System.out.println();
}

----------------------------------------------------------------------
*  *  *  *  * 
*  *  *  *  * 
*  *  *  *  * 
*  *  *  *  * 
*  *  *  *  * 

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=5;j++)
   {
      System.out.print(" * ");
   }

   System.out.println();
}
--------------------------------------------------------------------------
A  B  C  D  E  
A  B  C  D  E  
A  B  C  D  E  
A  B  C  D  E 
A  B  C  D  E 

char ch = 'A';

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=5;j++)
   {
      System.out.print(ch + "  ");
      ch++;
   }

   ch = 'A';
   System.out.println();
}
-------------------------------------------------------------------------
A   A   A   A   A
B   B   B   B   B
C   C   C   C   C
D   D   D   D   D
E   E   E   E   E

char ch = 'A';

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=5;j++)
   {
      System.out.print(ch + "  ");
   }

   ch++;
   System.out.println();
}
------------------------------------------------------------------------------
A  B  C  D  E
F  G  H  I  J
K  L  M  N  O
P  Q  R  S  T
U  V  W  X  Y

char ch = 'A';

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=5;j++)
   {
      System.out.print(ch + "  ");
      ch++;
   }
   System.out.println();
}
------------------------------------------------------------------------------
1
1  2
1  2  3
1  2  3  4
1  2  3  4  5        

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=i;j++)
   {
      System.out.print(j + "\t");
   }
   System.out.println();
}

---------------------------------------------------------------------------
1
2  2
3  3  3
4  4  4  4
5  5  5  5  5

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=i;j++)
   {
      System.out.print(i + "\t");
   }
   System.out.println();
}
----------------------------------------------------------------------------
1
2  3
4  5  6
7  8  9  10
11 12 13 14 15

int n = 1;

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=i;j++)
   {
      System.out.print(n + "\t");
      n++;
   }
   System.out.println();
}
-----------------------------------------------------------------------------
* 
*  * 
*  *  *
*  *  *  *
*  *  *  *  *

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=i;j++)
   {
      System.out.print(" * ");
   }
   System.out.println();
}
-----------------------------------------------------------------------------
A 
A  B  
A  B  C
A  B  C  D
A  B  C  D  E

char ch = 'A';

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=i;j++)
   {
      System.out.print(ch + "  ");
      ch++;
   }
   
   ch = 'A';
   System.out.println();
}
----------------------------------------------------------------
A 
B  B
C  C  C
D  D  D  D
E  E  E  E  E

char ch = 'A';

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=i;j++)
   {
      System.out.print(ch + "  ");
   }
   
   ch++;
   System.out.println();
}
-------------------------------------------------------------------------
A
B  C
D  E  F
G  H  I  J
K  L  M  N  O

char ch = 'A';

for(int i=1;i<=5;i++)
{
   for(int j=1;j<=i;j++)
   {
      System.out.print(ch + "  ");
      ch++;
   }
   
   System.out.println();
}

-----------------------------------------------------------------------
5   4   3   2   1
5   4   3   2
5   4   3
5   4
5

for(int i=1;i<=5;i++)
{
   for(int j=5;j>=i;j--)
   {
      System.out.print(j + "   ");
   }
   System.out.println();
}
-------------------------------------------------------------------------
1  1  1  1  1
2  2  2  2
3  3  3 
4  4 
5

for(int i=1;i<=5;i++)
{
   for(int j=5;j>=i;j--)
   {
      System.out.print(i + "   ");
   }
   System.out.println();
}

---------------------------------------------------------------------------
*  *  *  *  *
*  *  *  *
*  *  *
*  *
*

for(int i=1;i<=5;i++)
{
   for(int j=5;j>=i;j--)
   {
      System.out.print("  *  ");
   }
   System.out.println();
}
-------------------------------------------------------------------------------
A  B  C  D  E
A  B  C  D
A  B  C
A  B
A

char ch = 'A';

for(int i=1;i<=5;i++)
{
   for(int j=5;j>=i;j--)
   {
      System.out.print(ch + "   ");
      ch++;
   }

   ch = 'A';
   System.out.println();
}
-----------------------------------------------------------------------------
             *
          *  *  *
       *  *  *  *  *
    *  *  *  *  *  *  *  
 *  *  *  *  *  *  *  *  *

int rows = 15;

    for(int i=1;i<=rows;i++)
    {
      for(int j=rows-1;j>=i;j--) {
         System.out.print("   ");
      }

      for(int k=1;k<=2*i-1;k++) {
         System.out.print(" * ");
      }

      System.out.println();
    }

------------------------------------------------------------------------------
             A
          A  B  C
       A  B  C  D  E
    A  B  C  D  E  F  G  
 A  B  C  D  E  F  G  H  I

char ch = 'A';		

for(int i=1;i<=rows;i++)
{
   for(int j=rows-1;j>=i;j--) {
      System.out.print("   ");
   }

   for(int k=1;k<=2*i-1;k++) {
       System.out.print(ch + "  ");
       ch++;
   }

   ch = 'A';
   System.out.println();
}
--------------------------------------------------------------------------
*  *  *  *  *  *  *  *  *
   *  *  *  *  *  *  *
      *  *  *  *  * 
         *  *  *
            *


1  2  3  4  5  6  7  8  9
   1  2  3  4  5  6  7
      1  2  3  4  5
         1  2  3
            1

A  B  C  D  E  F  G  H  I  
   A  B  C  D  E  F  G
      A  B  C  D  E 
         A  B  C  
            A

-------------------------------------------------------------------------------------------
Program : write a java program to display all the prime numbers between 1 to 100.

(using nested loops only we can do this program)

for each loop :
--------------
- it is a special loop which is designed to access the elements of an array and collection

syntax:
  for(data-type varName : array/collection)
  {
    //statement(s);
  }

control flow statements
|- 1. selection statements
|- 2. iterative statements
|- 3. transfer statements (break, continue, return)

1. break :
   -----
- it is a keyword and a transfer statement.

- it can be used only in 3 places.

  i. inside the switch case
  ii. inside the loops
  iii. inside the named blocks

Note:
 - if we use break apart from above 3 places then compiler gives a compile time error saying 
   "break outside switch or loop".

 - if we want to terminate the flow of execution of switch case and to come out of switch case we
   use break inside the switch case.

 - if we want to terminate the iterations of the loop and to come out of the loop we use break
   inside the loops.

 - if we want to terminate the execution of a named block and to come out of the named block we 
   use break inside named blocks.

 - a block name must be a label.

 - a name which ends with colon : is called as label.

 - if we use break inside the named blocks we must have to specify the block name after break.

2. continue :
   --------
- it is a keyword and a transfer statement.

- it can be used only in 1 place i.e., inside the loops.

note:
 - if we use continue outside the loops anywhere the compiler gives a compile time error saying
   "continue outside the loops".

 - if we want to skip the iterations of the loop we use continue inside the loops.

3. return :
   ------
- it is a keyword and a transfer statement. 

- there are 2 uses of return statement :

  i. return statement is used to return a value to a method whose return type is other than void.

  ii. return statement is also used to return the control from called method to calling method.

types of variables :
------------------
---> based on the value which is stored by a variable, all variables are divided into 2 types
     in java.

     1. primitive variables

        - these variables hold single value.

          ex:
            int a = 10;
            double b = 2.5;
            char ch = 'a';

     2. reference variables

        - these variables hold object and object contains multiple values.

          ex:
            String str = new String("hyderabad");


---> Based on the position of declaration and scope of the variables, all variables are divided
     into 3 types in java.
 
     1. instance variables
     2. static variables
     3. local variables

1. instance variables :
   ------------------
-> if the value of a variable has to be different from one object to another object then use
   instance variables.

-> instance variables are declared directly inside the class but not inside any method or a
   block or a constructor.

-> instance variables are created (memory allocated) at the time of object is created.

-> instance variables are created (memory allocated) inside the object and object is created
   inside the heap area.

-> initialization of instance variables is optional, if we dont initialize then jvm takes the
   responsibility to initialize them with default values.

-> instance variables are also called as object variables.

-> instance variables are object members.

-> scope and lifetime
 
   - the scope of instance variables is same as object scope.
   - the lifetime of instance variables is same as object lifetime.

-> instance variables cannot be accessed directly from static methods and static blocks.

-> every object has a seperate copy of same instance variables.

-> as instance variables are associated with object so to access instance
   variables we must have to use object.

   syntax:
      objName.instanceVariableName;

-> if we modify instance variables using one object it never impacts other objects because
   every object has a seperate copy.

static variables :
----------------
-> if the value of a variable has to be same from one object to another object then use static
   variables.

-> static variables are also declared directly inside the class but not inside any method or 
   a block or a constructor but using a static keyword.

-> static variables are created (memory allocated) only once at the time of classloading.

-> static variables are created (memory allocated) in jvm's method area.

-> initialization of static variables is also optional, if we dont initialize then jvm initia-
   lizes them with default values.

-> static variables are also called as class variables.

-> static variables are class members.

-> scope and lifetime

   - the scope of static variables is same as class scope.
   - the lifetime of static variables is same as class lifetime.

-> static variables can be accessed directly from static methods and static blocks.

-> every object from heap area shares a single copy of static variables from method area.

-> static variables are associated with class but not object so to access
   static variables we no need object we can access using classname.

   syntax:
      ClassName.staticVariableName;

-> if we modify the static variables using one object it impacts other objects also because
   every object shares a single copy of static variable.

local variables :
---------------
-> if the requirement of the program or the programmer is to use some variables for temporary
   purpose then use local variables.

-> local variables are declared directly inside a method or a block or a constructor but not
   inside the class directly.

-> local variables are created (memory allocated) whenever method or block or constructor
   execution starts.

-> local variables are created (memory allocated) in java stacks.

-> initialization of local variables is mandatory at the time of declaration and before 
   accessing.

-> local variables are also called as temporary variables or automatic variables.

-> local varialbes are block members.

-> scope and lifetime
 
   - local variables scope is within the method or a block only.
   - the lifetime of local variables is until the method or block execution completes.

-> the only modifier which is allowed for local variables is final.

what is a method?

- a reusable block of statements which is return to perform some specific
  operation is called as a method.

different parts of a method :
---------------------------
1. method name with parenthesis
2. return type 
3. may or may not have parameters or arguments
4. modifier
5. may or may not have return statement
6. method body or implementation

return type :
-----------
- before a method name if we use any data type then it is called return
  type of a method.

- return type indicates whether a method returns a value or not.

- a method whose return type is other than void such method returns value.

- a method whose return type is void such method will not return any value.

int add()
{
}

float sub()
{
}

void mul()
{
}

return statement :
----------------
- return statement is used to return a value to a method whose return type
  is other than void.

ex:
 int add()
 {
    return 10+20;
 }

 void sub()
 {
   return 5-2;   //c.e
 }

- void methods never return any value.

parameters (arguments)
----------
- if we use any variables within the parenthesis of a method such variables
  are called as parameters.

- so parameters are variables only i.e., local variables.

- parameters are not only used to hold the data but also used to pass the
  data and receive the data from outside.

- there are 2 types of parameters

 1. actual parameters
  
  - these parameters are used to pass the data to formal parameters.
       
 2. formal parameters

  - these parameters are used to receive the data from actual parameters.

int a;   //a and b are variables but not parameters  
int b;

- variables are used to hold data.

void add(int a, int b)   //here a and b are parameters as well as variables
{
}


different sections of a method :
------------------------------
- a method has 2 sections

  1. method header or method prototype
 
     - it consists of method name, parameters, return type and modifier.
 
  2. method body or implementation

     - it consists of statements.

categories of methods
---------------------
- a method has 4 different categories

1. method without parameters or arguments and without return statement.
2. method without parameters or arguments and with return statement.
3. method with parameters or arguments and without return statement.
4. method with parameters or arguments and with return statement.

types of methods in java :
------------------------
1. instance methods

   i. mutator or setter methods
   ii. accessor or getter methods

2. static methods

3. factory methods

   i. instance factory method
   ii. static factory method

instance methods :
----------------
- a method which can access instance variables of a class directly and to
  call a method if object is mandatory such method is called as instance
  method.

- instance methods are created at the time of object is created.

- instance methods are created outside the object that is in heap area
  directly.

- instance methods can also access static variables of a class directly.

class One
{
   int i = 10;   //instance variable
   static int j = 20;   //static variable

   public void methodOne()   //instance method
   {
      System.out.println(j);
   }
}



mutator or setter methods :
-------------------------
- mutator or setter methods are instance methods only and they are used to set or modify
  the values of instance variables thats why they are called as mutator or setter methods.

accessor or getter methods :
--------------------------
- accessor or getter methods are instance methods only and they are used to access or get
  the values of instance variables thats why they are called as accessor or getter methods.

note:
 --> in short, accessor or getter methods and mutator or setter methods are called as
     setters and getters. 

static methods :
--------------
- a method which is declared using static keyword and to call method if object is not required
  and a method which cannot access instance variables of a class directly is called as static
  method.

- static methods can access only static variables of a class directly.

- static methods are created at the time of classloading as part of heap area.

- static methods are associated with a class rather than an object.

- we can access static method not only using classname but using object also.

class One
{
   int i = 10;  //instance variable
   static int j = 20;    //static variable

   public static void methodOne() 
   {
      System.out.println(j);   //20
      System.out.println(i);  //c.e: non-static variable cannot be referenced from static area
   }
}

note:
 - instance variables are sometimes called as non-static variables also.

factory method :
--------------
- a method which creates and returns the object of another class is caleld as factory method.

- a factory method can be an instance method or static method.

- if factory method is instance method then it is called as instance factory method and
  if factory method is static method then it is called as static factory method.

- a class which contains factory method is called as factory class.

- to call instance factory method we need to create object of factory class.

- to call static factory method we no need to create object of factory calss
  we can call using factory class name directly.

factory means which creates something

class A
{
}
- in java we create object to a class using new operator but always it is
  not easy to create object to a class using new operator sometimes it becomes
  difficult to create object using new operator in this case to create object
  to such class we have to go for factory method.

i dont have car
    |
i want car
  

can i create the car?
- if creating the car is easy i can create the car but creating the car
  is difficult thats why i cannot create the car.

- so i cannot create car but i want car

- car factory can create the car (because they know the procedure of creating car)

- i should go to car factory and ask car factory to create and give me 
  a car.

- car factory will create and give the car.

user-defined factory method :
---------------------------
i. instance factory method

ex:
  class Car
  {
     int regno = 123;
 
     public void drive() {
       System.out.println("driving car...");
     }
  }

note:
 - we can create object to Car class using new operator but assume we cannot
   create object to Car class using new operator

   class CarFactory          //factory class
   {
      public Car createCar()     //instance factory method
      {
          Car c = new Car();   //here c is an object of Car class
          return c;
      }         
   }

note:
 - a method whose return type is a class means that method creates and returns
   the object of that class.

   public class InstanceFactoryMethodTest
   {
      public static void main(String args[])
      {
         CarFactory cf = new CarFactory();
         Car c = cf.createCar(); 
         System.out.println("regno : " + c.regno);
         c.drive();
      }
   }

ii. static factory method 

ex:
  class Car
  {
     int regno = 123;
 
     public void drive() {
       System.out.println("driving car...");
     }
  }
note:
 - a method whose return type is a class means that method creates and returns
   the object of that class.

   class CarFactory       //factory class
   {
       public static Car createCar()   //static factory method
       {
           Car c = new Car();
           return c;
       }
   }
  
   public class StaticFactoryTest
   {
       public static void main(String args[])
       {
          Car c = CarFactory.createCar();
          System.out.println("regno : " + c.regno);
          c.drive();
       }
   }

predefined factory methods :
--------------------------
- there are several predefined factory methods are there in java but
  right now we are learning 2 important predefined factory methods.

1. forName()
2. newInstance()  

--> in java.lang package we have a class whose name is Class. 

java.lang
|- Class
   |- public static Class forName(String className) //return type of forName() is Class class
                         
- forName() factory method loads a class explicitly into jvm's memory, creates Class 
  class object, stores the information of loaded class in Class class object and returns
  Class class object.     

java.lang
|- Class
   |- public Object newInstance()   //return type of newInstance() is Object class

- newInstance() factory method get the name of the loaded class from Class class object,
  creates loaded class object, store in Object class reference variable and returns.

---------------------------------------------------------------------------------------
- Class class object is used to hold the information of other classes, information like 
  name of the class, method names, variables names etc.

- forName() and newInstance() methods are available in Class class.

- forName() method returns the object of Class class.

- forName() is a static factory method.
----------------------------------------------------------------------------------------
- Object class is the super class or parent class for all the classes in java.

- Using Object class reference variable can we hold any sub class object.

ex:
  class Employee {
  }

  Employee emp = new Employee();  //valid

  Object obj = new Employee();   //valid

- a method whose return type is a class means that method creates and returns the
  object of that class.

  ex:
    class Employee {
    }

    public Employee methodOne() 
    {
       Employee emp = new Employee();
       return emp;
    }

- a method whose return type is Object class means that method creates and returns
  the object of any class.

  ex:
     class Employee {
     }
 
     class Student {
     }
  
     public Object methodOne() 
     {
        Object obj = new Employee();
        return obj;
     }

     public Object methodTwo() 
     {
        Object obj = new Student();
        return obj;
     }

     public Object methodThree() 
     {
        Object obj = new Object();
        return obj;
     }

class One
{
}

One obj = new One();

- whenever we use new operator to create object to a class
  directly jvm will not create object to a class before
  creating object first jvm loads a class into jvm's memory
  this is called implicit classloading.

- after the class is loaded then jvm creates object.

--> if we want to create object to a class without using new operator 
    we must have to follow 2 steps

    1. load the class explicitly into jvm's memory
    2. create object to loaded class
    
- using forName() factory method we can load a class explicitly into
  jvm's memory.

- using newInstance() factory method we can create object to loaded class.

- creating object is a 2 step process
  i. loading ii. creating
        |           |
    forName()    newInstance()

constructors :
------------
what is a constructor and why we use a constructor?

- a constructor is like a special method which is called and executed automatically by the jvm at
  the time of creating an object.

- constructor is used to initialize the instance variables only.

rules for writing a constructor :
-------------------------------
1. a constructor name must be same as class name and ending with parenthesis. 

2. a constructor cannot have a return type not even void.

3. a constructor cannot have return statement also.

4. a constructor can have access modifier like public, private, protected and default.

5. a constructor must have a body.

6. a constructor may or may not have parameters or arguments.

note:
 - a constructor which does not have any parameters or arguments is called as zero parameterized or
   zero argument constructor and a constructor which has a parameter or argument then it is called
   as parameterized constructor or argument constructor.

 - to see what is there in class file (.class file) we use javap command.

 - if we dont write any constructor in a class by default java compiler writes one default
   constructor which is a zero parameterized constructor.

 - we cannot write multiple constructors within the same class with same name and same parameters.

 - we can write multiple constructors within the same class with same name but with different 
   parameters.

what is constructor overloading?
- writing two or more constructors within the same class with difference in parameters or arguments
  is called as constructor overloading and such constructors are called as overloaded constructors.

Note:
 - if we use constructors then we can initialize the instance variables in every object with different
   values.

--------------------------------------------------------------------------------
ex-1:
   class One             
   {              //default constructor will be there 
   }

   One obj = new One();    //it works

ex-2:
   class One
   {
      public One(int i) {
      }
   }

   One obj = new One();   //it will not work, it gives compile time error

ex:-3
   class One
   {
      public One(int i) {
      }
   }

   One obj = new One(10);   //it works

ex-4:
   class One
   {
      public One() {
      }

      public One(int i) {
      }

      public One(int i, double j) {
      }
   }

   One obj1 = new One();  //it works

   One obj2 = new One(10);   //it works

   One obj3 = new One(10, 20.0);   //it works

   One obj4 = new One("hello");   //it will not work, it gives error

   One obj5 = new One(10, 20);  //it works

   One obj6 = new One(2.5);   //it will not work, it gives error


static block (static initializer)
------------
- a block which is declared using static keyword and which is used to initialize
  the static variables is called as static block.

ex:
 static       //static block or static initializer
 {
 }

- static blocks are executed at the time of classloading.

- static blocks are executed only once because a class is loaded only once.

- if a class is having multiple static blocks then all the static blocks are
  executed in the order in which they are declared.

- static blocks are executed even before main method.

- static blocks are written directly inside the class but not inside any method.

----------------------------------------------------------------------------------
class A
{
   int i = 10;

   void m1() {
   }
   
   void m2() {
   }
}

class B
{
   void m3() {
   }

   void m4() {
   }
}

- one class can access or use the members of another class in java.

In how many ways one class can access or use the members of another class in java?

- there are 2 ways using which one class can access or use the members of another class.

  1. inheritance
  2. composition

inheritance : 
-----------
 - acquiring the properties of one class into another class is called as inheritance.
  
 - to use inheritance we use extends keyword.

 - inheritance establishes is-a (parent-child) relationship between the classes.

ex:
   class A                   //parent class or super class or base class
   {
     int i = 10;

     void m1() {
     }
   
     void m2() {
     }
   }

   class B extends A           //child class or sub class or derived class
   {
      void m3() {
      }

      void m4() {
      }
    }
  
- in inheritance it is always recommended to create object to sub class.

   B b = new B();
   b.m3();
   b.m4();
   b.m1();
   b.m2();

composition :
-----------
- composition is the relationship between two objects where one object has the reference
  of another object to access the members.

- to use composition there is no specific keyword but we use new operator only.

- composition establishes has a relationship between the classes or objects.

ex:
  class A
  { 
     int i = 10;

     void m1() {
       System.out.println("from m1"); 
     }

     void m2() {
       System.out.println("from m2"); 
     }
  }

  class B
  {
     A a;  //creating reference variable of class A as an instance variable in class B    

     void m3() {
       a = new A();
       a.m1();
       System.out.println("from m3");
     }
  
     void m4() {
        a.m2();
        System.out.println(a.i);
        System.out.println("from m4");
     }
  }

  B b = new B();
  b.m3();
  b.m4();

----------------------------------------------------------------------------------------
class Engine
class Car

Car has Engine (Car class wants to access the members of Engine class)

class Engine
{
   int engineNo = 123;

   public void start() {
     System.out.println("engine started...");
   }
}

class Car
{
   Engine en;

   public void drive() 
   {
      en = new Engine();
      en.start();
      System.out.println("driving car...");
      System.out.println("engine no = " + en.engineNo);
   }
}

public class CompTest
{
  public static void main(String args[])
  {
    Car c = new Car();
    c.drive();
  }
}

--------------------------------------------------------------
Sim
|- simNo
|- recharge()

Mobile
|- imeiNo
|- makeCall()

class Sim
{
   int simNo;

   public Sim(int simNo) {
     this.simNo = simNo;
   }

   public void recharge() {
      System.out.println("recharge successuful");
   }
}

class Mobile
{
   int imeiNo;
   Sim s;

   public Mobile(int imeiNo, Sim s) {
     this.imeiNo = imeiNo;
     this.s = s;
   }   

   public void makeCall()
   {
      s.recharge();
      System.out.println("making call...");
      System.out.println("sim no = " + s.simNo);
      System.out.println("imei no = " + imeiNo);
   }
}

public class MyApp
{
   public static void main(String args[])
   {
      Sim s = new Sim(34625); 
      Mobile m = new Mobile(12345, s);
      m.makeCall();
   }
}
--------------------------------------------------------------
classloaders :
------------
- classloaders are special java classes which are responsible to load the classes from
  a particular location in a computer into jvm's memory.

- there are 3 classloaders in java

  1. bootstrap classloader
  2. extension classloader
  3. system/app classloader

- 3 different classloaders load the classes from 3 different locations.

C:
|- Program Files
   |- Java
      |- Jdk_1.8
         |- bin   (development tools ex: javac.exe, javap.exe, jar.exe etc)
         |- jre (jre_home)
            |- bin  (java.exe file is called jvm)
            |- lib  (rt.jar -> class library)
               |- rt.jar
               |- ext 
                  |- jar files 
                     |- extension api classes and interfaces

rt.jar 
|- all core java predefined api classes and interfaces

ex:
  String.class, System.class, Calendar.class, Scanner.class etc

- a jar contains class files (.class files).

1. bootstrap classloader 
   |- jre_home/lib/rt.jar

2. extension classloader
   |- jre_home/lib/ext/jars
   |- java.ext.dirs  (system property)         //we will discuss later
 
3. system/app classloader
   |- CLASSPATH
   |- -cp or -classpath
   |- Class-Path attribute pointed classes of manifest file   //we will discuss later


Employee.class -> i want extension classloader to load this class

answer: place Employee.class file inside ext directory.

Employee.class -> i want system/app classloader to load this class

answer: place Employee.class file in classpath.


what is classpath?

- classpath is a system variable or environment variable which is used
  by compiler and jvm to search for the location of required class files.
  
- .class files are called as class files.


in classpath, class means .class file and path means location

classpath means .class file location

note:
 - if we dont set any classpath environment variable then the default classpath will
   be current directory.

 - in command prompt in which directory currently we are working is called current
   directory.
 
 - always the required .class files will not be available in current directory, sometimes
   .class files will be available in different directory location in this case we need
   to change the classpath.

 - compiler and jvm always search for .class files in classpath.

 - System/App classloader is a sub class of Extension classloader
   and Extension classloader is a sub class of Bootstrap classloader.
 
 - Bootstrap classloader is the top most classloader in classloaders hierarchy and it
   does not have any parent thats why it is called as ultimate classloader.

 - In classloader hierarchy the least child classloader is system/app classloader.

principles of classloading :
--------------------------
- at the time of loading the classes, classloaders follow some principles.

- there are 3 principles of classloading.

  1. principle of delegation
  2. principle of uniqueness
  3. principle of visibility

- whenever we run a class or create object to a class first jvm asks the least
  child class loader i.e., system/app classloader to load the class first but
  system/app classloader follows principle of delegation which means system/app
  classloader delegates the responsibility of loading the class to its parent
  classloader i.e., extension classloader and extension classloader also follows
  principle of delegation which means it also delegates the responsibility of
  loading the class to its parent i.e., bootstrap classloader as bootstrap class
  loader is the ultimate classloader it goes jre_home/lib/rt.jar and searches 
  for class file, if class file is available it loads the class into jvm's memory
  or if class file is not available then control comes to its child classloader
  i.e., extension classloader which goes to jre_home/lib/ext/jars and searches
  for class file, if class file is there it loads it and if not there then the
  control comes its child classloader i.e., system/app classloader which searches
  for class file in classpath, if available it loads it and if not available it
  gives error this is called as principle of delegation.

- no two classloaders are allowed to load the same class multiple times into jvm's
  memory this is called principle uniqueness.

- parent classloaders loaded class will be visible to all the classes which are
  loaded by child classloaders but child classloaders loaded classes will not be
  visible to the classes which are loaded by parent classloaders this is called 
  principle of visibility.

phases of classloading :
----------------------
- there are 3 phases of classloading

1. loading

2. linking
   i. verifying
   ii. preparing
   iii. resolving  
 
3. initializing

loading :
-------
- a classloader goes to a particular location in a computer and searches for class
  file, once the class file is identified and available then classloader starts 
  reading the byte code from class file using io streams and places inside jvm's
  method area.

verifying :
---------
- once the byte code is loaded and available in jvm's method area then byte code
  verifier starts verifying whether the byte code is valid or invalid.

- if the byte code is valid then only byte code will be executed otherwise byte
  code will not be executed simply jvm gives error.

preparing :
---------
- in preparing phase, jvm creates Class class object to represent the information
  of the loaded classes and static variables are also created in method area with
  default values.

resolving :
---------
- in resolving phase class names references will be converted to direct references
  in the memory.

class Engine {
}

class Car
{
   Engine en;
}

Engine.class (byte code)

Car.class (byte code)

byte code -> symbolic representation

initializing :
------------
- all the static blocks are executed and static variables are initialized with some
  values in initializing phase.

----------------------------------------------------------------------------------
Method Area :
-----------
- classes are loaded in method area.
- all class level information is stored in method area.

class level infromation -> fully qualified class name, fully qualified name of the 
                           parent class, variable names, method names, constructor 
                           names

Heap Area :
---------
- objects are created in heap area.

- after the classes are loaded, jvm creates Class class objects in heap area to
  represent the information of loaded classes.

note:
 - per jvm one method area is created and one heap area created.

java stacks :
-----------
- per jvm there will be multiple java stacks can be there.

- per thread jvm creates one java stack.

- method name and local variables are stored in java stacks.

pc registers (program counter registers)
------------
- for every thread jvm creates one pc register.

- the information of the instruction which a thread is executing will be stored
  in pc register.

native method library :
---------------------
- internally jvm uses native languages functions which are available in native 
  method library.

java native interface (jni) :
---------------------------
- using the help of java native interface we can call native languages functions
  in java.

native method stacks :
--------------------
- the information of native languages functions is stored in native method stacks.

execution engine :
----------------
- it is responsible for executing java programs.

i. interpreter
ii. jit compiler
iii. garbage collector

- interpreter and jit compiler are responsible to convert byte code into machine 
  code on the fly and jvm gives machine code to cpu to execute.

- garbage collector goes to heap area of jvm and searches for unused objects, if
  any unused objects are available then garbage collector removes those objects
  from jvm's heap area to free the memory.


this :
----
- this is a keyword in java and a self reference variable which refers to current class
  object and its members.

- every object has two types of reference variables

  1. external reference variable
  2. self reference variable

- external reference variable is created by the programmer and it can
  be used in any class where as self reference variable is created by 
  the jvm and it can be used only within the same class.

class A
{
  this   -> it refers to current or same class object
}

class B
{
  this  -> it refers to current or same class object 
  A a;  -> it refers to class A object
}

uses of this keyword :
--------------------
1. this keyword is used to refer or access to current class instance variables.
  
   syntax:
      this.varName;

2. this keyword is used to refer or access to current class instance methods.
 
   syntax:
      this.methodName();

3. this keyword is used to refer or access to current class constructors.

   syntax:
       this();    or    this(parameters);

4. this keyword is used to refer or access to current class object.

   syntax:
      this;

note:
 --> constructor caller must be the first statement in a constructor.

singleton class :
---------------
- a class which allows to create only one object is called as
  singleton class.

class Account
{
}

Account obj1 = new Account();
Account obj2 = new Account();
Account obj3 = new Account();
.
.
.
.
etc

- a class which allows to create more than one object is called as 
  non-singleton class.

- by default every class is non-singleton class.

class Account                     //lazy instantiation
{
   private static Account instance;

   private Account() {
      //no-code
   }  

   public synchronized static Account getInstance()
   {
       if(instance == null) {
          instance = new Account(); 
       }
       
       return instance;
   }
}

Account obj1 = Account.getInstance();
Account obj2 = Account.getInstance();

System.out.println(obj1 == obj2);   //true
System.out.println(obj1.hashCode());
System.out.println(obj1.hashCode());

.
.
.


Account obj1 = new Account();   //c.e
Account obj2 = new Account();   //c.e
.
.
.

steps to make a class as singleton :
----------------------------------
step-1: make the constructor as private

step-2: write static factory method

step-3: write condition to check whether object is created or not, if 
        object is not created then create the object and return and 
        if object is already created then return the same object.

step-4: factory method should check whether object is created or not
        and if not created factory method should store the object in
        global variable and return, next time when we call the factory
        method it should go to global variable and checks object is
        created or not so object is available then it should return
        the same object.

step-5: to make the class perfect singleton in multi-threaded 
        environment we have to declare the static factory method
        using synchronized keyword.


best practices for singleton class :
----------------------------------
1. use factory method name as getInstance().

2. use singleton reference variable as instance.

3. use if condition instead if else condition.

4. dont leave empty blocks as it is, always use a comment with
   no code.


class Employee
{
   int id;

   public void getId() {
   }
}

- we can make a singleton class as :

1. lazy instantiation

   - if the singleton class object is created after calling the
     static factory method then it is called lazy instantiation.

2. eager instantiation

   - if the singleton class object is created before calling the
     static factory method and at the time of singleton class is
     loaded then it is called eager instantiation.

how to make a singleton class as eager instantiation :
----------------------------------------------------

class Account             //eager instantiation
{
   private static Account instance;

   private Account() {
     //no-code
   }

   static {
      instance = new Account();
   }

   public static Account getInstance() {
      return instance;
   }
}

Account obj1 = Account.getInstance();
Account obj2 = Account.getInstance();
------------------------------------------------------------------------
doubleton class :
---------------
class Account                     
{
   private static Account instance;
   private static int count;

   private Account() {
      //no-code
   }  

   public synchronized static Account getInstance()
   {
       if(count < 2) {
          instance = new Account(); 
          count++;
       }
       
       return instance;
   }
}
-------------------------------------------------------------
io streams :
----------
- io streams --> input output streams

- io streams is an api given by sun micro systems.

- api means predefined classes

- using io streams predefined classes we can read the data from file,
  write the data to a file, read the data from keyboard and write the
  data to console etc.

what is stream?
- a stream is a logical connection between two things and those two things
  can be a java program and a file or a java program and keyboard or a
  java program or a console etc.

- using stream (logical connection) we can transfer the data.

- transferring the data means either reading the data or writing the data.

types of streams :
----------------
there are 2 types of streams in java

1. binary streams

   -> these streams transfer binary data byte by byte.

   -> these streams transfer 8 bits of data at a time.

2. character streams
  
   -> these streams transfer character data character by character.

   -> these streams transfer 16 bits of data at a time.


----------------------------------------------------------------------------------
classname
|- input or reader    ->  reading

classname
|- output or write     ->  writing

classname
|- stream without reader or writer   ->  binary stream class

classname
|- reader or writer and with or without stream   ->  character stream class


PrintWriter  ->  character stream class, writing

DataInputStream  ->  binary stream class, reading

FileOutputStream ->  binary stream class, writing

InputStreamReader -> character stream class, reading

OutputStreamWriter -> character stream, writing

--------------------------------------------------------------------
InputStreamReader :
-----------------
- it is a sub class of Reader so it is a character stream class and it is used
  to read characters.

- InputStreamReader is a bridge between binary stream and character stream which
  means InputStreamReader reads binary data and converts into character data using
  a character set encoding.

Note:
 -->  standard input stream represents keyboard in java  (System.in)
 -->  standard output stream represents console in java  (System.out)
 
 --> Buffered classes are only meant for improving the performance of character
     streams and binary streams but using buffered classes we cannot read and
     write the data directly.

Methods Of BufferedReader :
-------------------------
1. int read() : it reads single character and returns its ascii.

2. String readLine() : it reads a string (line of text).

3. long skip(long) : it skips the characters

4. void close() : it closes the stream and releases system resources.

system resources means keyboard, console, file, object, array etc

Note:
 --> there are no methods available in BufferedReader class to read integer, 
     floating and boolean values.
 
 --> all the methods of BufferedReader class throws IOException which is a
     checked exception.


How to read integer, floating and boolean values using BufferedReader?

answer: to read integer, floating and boolean values using BufferedReader we have
        to use readLine() method only but it reads all the values as string type
        so after reading the values convert into appropriate types.

How to convert a string into primitive type?
- using parse methods

wrapper class: a wrapper class is used to convert a single primitive value into 
               an object.

- for every primitive datatype sun micro system has given appropriate wrapper class.

ex:
  int -> Integer, float -> Float, char -> Character, double -> Double etc

- all the wrapper classes are available in java.lang package.

parse methods :
-------------
- parse methods are used to convert a string into primitive type.

- all parse methods are static methods available in wrapper classes.

Integer 
|- static int parseInt(String s)

Float
|- static float parseFloat(String s)

Double
|- static double parseDouble(String s)

Boolean 
|- static boolean parseBoolean(String s)

etc

ex-1:
  String str = "10";

  int i = Integer.parseInt(str);

ex-2:
  String str = "2.5";

  double j = Double.parseDouble(str);  


Scanner :
-------
- it is a class in java.util package.

- using Scanner also we can read the data from keyboard at runtime.

- Scanner is a simple text scanner which means Scanner reads inputs as text
  and breaks the text into small small parts called as tokens using space as
  delimiter.

- in Scanner class sun micro system has provided several methods which converts
  the text into appropriate primitive types.

computer is a machine   --->  text

   after breaking

computer  -->  tokens 
is 
a 
machine

methods of Scanner :
------------------
1. String next() --> it reads a string until space.
2. String nextLine() --> it reads a string until enter is pressed.
3. int nextInt() --> it reads integer.
4. float nextFloat() --> it reads a floating value.
5. double nextDouble() --> it reads a double value.
6. boolean nextBoolean() --> it reads a boolean value.
   etc

note:
 --> there is no method to read a character.

arrays :
------
- arrays are indexed collection of fixed number of homogeneous elements.

- in simple, we can say arrays are collection of similar elements.

- types of arrays

  i. one dimensional arrays (1d arrays)
  ii. multi dimensional arrays (2d, 3d arrays)

- to create arrays we use subscript operator [].

declaration of 1d arrays :
------------------------
1. int a[size];   //c.e: at the time declaring an array we cannot give sign
2. int a[];
3. int []a;
4. int[] a;   //recommended

declaration of 2d arrays :
------------------------
1. int a[][];
2. int a[3][4];   //c.e
3. int [][]a;
4. int[][] a;
5. int []a[];
6. int[] []a;
7. int[] a[];

declaration of 3d arrays :
------------------------
1. int a[][][];
2. int [][][]a;
3. int[][][] a;
4. int[] [][]a;
5. int[][] []a;
6. int[] a[][];
7. int a[3][4][5];   //c.e

- once we declare an array, an array will not be created.

Note:
 --> in java, everything is represented as class or object so arrays are also
     classes in java.

 --> we use new operator to create object to any class so as arrays are classes
     in java, we use new operator only to create array.

creation of 1d array :
--------------------
syntax:
   data-type varName[] = new data-type[size];

- at the time of creating an array size is mandatory.

- at the time of declaring an array we cannot give the size.

- here varName is array variable which is also a reference variable.

ex:
  1. int a[] = new int[5]; 
  2. float[] b = new float[8];
  3. char []ch = new char[20];
  4. String[] str = new String[3];

initialization of 1d array :
--------------------------
- there are 2 ways

1. compile time initialization

   i. single line initialization
   
      ex:
        int[] arr = {1,2,3,4,5};
        double[] a = {1.1,2.2,3.3};
        char[] ch = {'a','b','c','d','e'};
        String[] str = {"one", "two", "three"};

   ii. multi line initialization

      ex:
        int[] arr = new int[3];

        arr[0] = 10;
        arr[1] = 20;
        arr[2] = 30;
        arr[3] = 40;   //AIOOBE

2. runtime initialization

   ex:
     int[] arr = new int[5];
     BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

     for(int i=0;i<arr.length;i++)
     {
        System.out.print("enter arr[" + i + "] : ");
        arr[i] = Integer.parseInt(br.readLine());   
     }

     enter arr[0] : 10
     enter arr[1] : 20
     enter arr[2] : 30
     .
     .

                          (or)

     Scanner sc = new Scanner(System.in);
  
     for(int i=0;i<arr.length;i++)
     {
        System.out.print("enter arr[" + i + "] : ");
        arr[i] = sc.nextInt(); 
     }

Note:
 --> In java, we can create an array without using new operator also that is
     by using single line initialization.


accessing elements of 1d array :
------------------------------
- there are 2 ways

1. one element at a time

   ex:
     int[] arr = {11, 21, 31, 41, 51};

     System.out.println(arr[0]);  //11
     System.out.println(arr[4]);  //51
     System.out.println(arr[1]);  //21
     System.out.println(arr[3]);  //41
     System.out.println(arr[2]);  //31
     System.out.println(arr[5]);  //AIOOBE

2. all elements at a time

   ex:
     int[] values = {10, 20, 30, 40, 50};

     for(int i=0;i<values.length;i++) {
        System.out.print(values[i] + "   ");
     }

10  20  30  40  50

program-1: write a java program to declare, create, initialize and access
           elements of 1d array.

program-2: write a java program to find the sum of all even elements of an
           array.

program-3: write a java program to find maximum element from an array.

-----------------------------------------------------------------------------
Note:
  --> In java, 2d arrays are implemented in array of arrays form but not 
      in matrix form.

creation of 2d arrays :
---------------------
syntax:
   data-type[][] arrVar = new data-type[size-1][size-2];
                                          
- here first size i.e., size-1 represents the base size of array.

- size-1 is mandatory but size-2 is optional.

initialization of 2d arrays :
---------------------------
- there are 2 ways

1. compile time initialization

   i. single line initialization

      ex:  
        int[][] arr = {{1,2,3},{4,5,6},{7,8,9}};
        double[][] values = {{1.1,2.2,3.3}, {4.4,5.5,6.6}};
        char[][] ch = {{'a','b','c'}, {'d','e','f'}, {'g','h','i'}};
        String str[][] = {{"one","two"},{"three","four"}};

   ii. multi line initialization

       ex:
         int[][] values = new int[2][2];

         values[0][0] = 11;
         values[0][1] = 21;
         values[1][0] = 31;
         values[1][1] = 41;
         values[1][2] = 51;   //AIOOBE

2. runtime initialization

   ex:
     int[][] elements = new int[3][4];
     Scanner sc = new Scanner(System.in);

     for(int i=0;i<elements.length;i+)
     {
        for(int j=0;j<4;j++)
        {
            System.out.print("enter elements[" + i + "][" + j + "] = ");
            arr[i][j] = sc.nextInt();
        }
     }

     enter elements[0][0] = 10
     enter elements[0][1] = 20
     .
     .

accessing elements of 2d arrays :
-------------------------------
- there are 2 ways

1. one element at a time

   ex:
     int[][] arr = {{1,2,3},{4,5,6},{7,8,9}};

     System.out.println(arr[0][2]);  //3
     System.out.println(arr[1][1]);  //5
     System.out.println(arr[2][2]);  //9
     System.out.println(arr[0][1]);  //2
     System.out.println(arr[2][1]);  //8
  
2. all elements at a time

    ex:
     int[][] arr = {{1,2,3},{4,5,6},{7,8,9}};

     for(int i=0;i<arr.length;i++)
     {
        for(int j=0;j<3;j++)
        {
           System.out.print(arr[i] + "    ");
        }
        System.out.println();
     }
   
1   2   3
4   5   6
7   8   9

programs

program-1: write a program to declare, create, initialize and display elements
           of 2d array.

program-2: write a program to find the sum of odd elements of an array.

program-2: write a program to perform matrix addition.


anonymous arrays :
----------------
- an array without a name is called as anonymous arrays.

- anonymous arrays are meant for instant use.

- we can use anonymous arrays only once.

syntax:
  new data-type[]{elements...}

  new data-type[][]{{elements},{elements}....}

command line arguments :
----------------------
--> the values which are passed to main method at the time of running a java
    program are called as command line arguments.

--> command line arguments are received by one parameter whose name is args of
    main method and store all the values as string type at args[0], args[1],
    args[2] so on indexes.

class Test
{
  public static void main(String[] args)
  {
     int n = args.length;
     System.out.println("n = " + n);

     for(int i=0;i<n;i++) {
        System.out.println("args[" + i + "] : " + args[i]);
     }
  }
}

n = 3
args[0] : 10
args[1] : hello
args[2] : true

java Test 10 hello true   ----->   command line arguments
           |   |    |
           |   |    |
           |   |   args[2]
           |   |
           |  args[1]
           |
         args[0]


assignment: write a program to find sum of two numbers and read values through
            command line arguments.

var-args : (variable length arguments)
--------
--> it is a feature which is added from jdk 1.5 onwards.

--> whenever if there is a change in parameters either we have to change the
    parameters of the same method or we need to write one more method with 
    different parameters we can resolve this using var-args.

--> if we use a method with var-args as parameters then we can call same method
    by passing 0 or more number of parameters.

note:
--> var-args can be used only as parameter.

syntax:
   data-type ...varName   (or)    data-type... varName

--> var-args are internally implemented as 1d array.


length :
------
--> it is property (variable) in arrays and it is applicable only for arrays.

--> it gives base size of array and it is int type.

ex-1:
   int[] arr = new int[5];

   int n = arr.length;
   System.out.println(n);   //5

ex-2:
   int[][] arr = new int[3][4];
 
   int n = arr.length;
   System.out.println(n);   //3


java.lang package :
-----------------
- most important classes of java.lang package are :

1. Object
2. String
3. StringBuffer
4. StringBuilder

Object :
------
- it is a class in java.lang package, Object class is the root class 
  in java classes hierarchy.

- Object is also the super class for all the classes in java.

- Object class contains several methods which are common to all the
  classes in java.

methods of Object class :
-----------------------
--> there are total 11 methods

1. toString()
2. getClass()
3. clone()
4. hashCode()
5. equals()
6. finalize()
7. wait()
8. wait(long)
9. wait(long, int)
10. notify()
11. notifyAll()

--> every class in java has Object as super class, Object class which is the super class
    for all the classes in java so Object class methods will be inherited and available
    to all the classes (sub classes).

1. toString() :
   ----------
--> it returns a string representation of the object.

syntax:
  public String toString()

note: 
  i. whenever we print or display any object then on every object by 
     default jvm internally calls toString() method.

  ii. whenever we print or display any object then on an object by default
      jvm calls toString() method, if toString() method is overridden in
      sub class then jvm calls sub class overridden toString() method and
      if toString() method is not overridden then jvm calls Object class 
      toString() method.

  iii. Object class toString() method gets the name of the class whose object
       is created, converts object reference number which is a hashcode number
       also into hexadecimal number, appends class name with @ symbol and hexa-
       decimal number and returns as a string.

  iv. toString() can also be used to convert any class object to string object.

      ex:
        class Employee {
        }

        Employee e = new Employee();
        String str = e.toString();
-------------------------------------------------------------------------
method overriding :
-----------------
--> overriding super class method in sub class with different method body
    or implementation is called as method overriding.

class Parents    //super class or parent class
{
   public void property() 
   {
      //house, car, flats, gold, silver etc --> method body or implementation
   }

   public void study()   //overriding method
   {
      //M.B.A    --> method body or implementation
   }
}

class Son extends Parents    //sub class or child class
{
   public void study()   //overridden method
   {
     //engineering
   }
}

Son s = new Son();
s.property();
s.study();
-------------------------------------------------------------------------
--> before creating any object first jvm loads the class into jvm's method area
    and to represent the information of loaded class jvm creates Class class 
    object at runtime then jvm takes the name of the loaded class form Class
    class object and created object to loaded class so for every object jvm 
    creates one Class class object at runtime.

2. getClass() :  
   ----------
   --> it returns runtime Class class object for this object.

syntax:
   public Class getClass()


note:
 --> in java.lang package we have a class whose name is Class and Class class object
     is used to hold the information of other classes.

 --> in Class class which is also a sub class of Object class sun micro system has
     overridden Object class toString() method which returns a string containing 
     class keyword and class name.

java.lang
|- Class
   |- String getName() : it returns the name of the class whose information is 
                         available in Class class object.


3. clone() : 
   -------
--> it is used to clone an object.

   syntax:
      protected Object clone() throws CloneNotSupportedException

what is object cloning?
--> creating an exact copy of an object is called as object cloning.

note:
 --> in object cloning a new object will be created but with same data. 

ex:
  class Employee implements Cloneable
  {
     int id;
     String name;

     public Employee(int id, String name) {
       this.id = id;
       this.name = name;
     }

     public Object clone() throws CloneNotSupportedException
     {
        Object obj = super.clone();
        return obj;
     } 
  }
  public class CloneTest
  {
     public static void main(String[] args) throws CloneNotSupportedException
     {
       Employee obj1 = new Employee(1, "ravi");
       Object o = obj1.clone();  
       Employee obj2 = (Employee)o;
       System.out.println(obj2.id + " -- " + obj2.name);
     }
  }

---------------------------------------------------------------------------
Note:
 --> super class protected members (variables or methods) will be inherited and 
     available directly in sub classes and they become private in sub classes.

ex:
class A        //super class or parent class
{
   protected void m1() {
      //addition of two numbers
   }
}

class B extends A    //sub class or child class
{ 
}

class Test
{
   public static void main(String[] args)
   {
      B b = new B();
      b.m1();  //c.e
   }
}
--------------------------------------------------------------------------
class A        //super class or parent class
{
   protected void m1() {
      //addition of two numbers
   }
}

class B extends A    //sub class or child class
{ 
   public void m1() {
      super.m1();
   }
}

class Test
{
   public static void main(String[] args)
   {
      B b = new B();
      b.m1();  
   }
}
---------------------------------------------------------------------------
class Employee {
   public void work() {
     System.out.println("working..");
   }
}

class Worker {
   public Object createObject()
   {
      Object o = new Employee();
      return o;
   }
}

Worker w = new Worker();
Object o = w.createObject();
o.work();  //c.e

Employee e = (Employee)o;
e.work();

Note:
  --> a method whose return type is a class means that method returns
      the object of that class.

  --> a method whose return type is Object class means than method can return
      the object of any class.
---------------------------------------------------------------------------
hashCode() and equals() :
-----------------------
syntax:
   public boolean equals(Object o)
   public int hashCode()

Note:
 --> String is a class in java, so creating a string in java means creating
     String class object.
ex:
  String s1 = "absdfewrsavxvczxfdsrewafsadfewrsadfasfasdf";  //1 lakh characters

  String s2 = "werasfxxcsdtewrterfsavasdfarewqeoulfdsuouo";  //1 lakh characters

-- here s1 and s2 are objects of string class.

Requirement: compare two strings (comparing strings means comparing data)

  System.out.println(s1 == s2);  //false  

--> if we use equality operators to compare strings, equality operator always
    compares object reference numbers.

--> if we want to compare strings we should not use equality operator.

--> to compare strings (means two strings data) in java we should use equals() 
    method.

ex:
  String s1 = "absdfewrsavxvczxfdsrewafsadfewrsadfasfasdf";  //1 lakh characters

  String s2 = "werasfxxcsdtewrterfsavasdfarewqeoulfdsuouo";  //1 lakh characters

  boolean b = s1.equals(s2);
  System.out.println(b);

--> if equals() methods compares two strings data character by
    character then it has to do 1 lakh comparisons which takes 
    more time and impacts performance thats why sun micro system
    has come up a concept called hashcode.

what is hashcode?
--> a hashcode is a unique integer number which is generated based
    on the data which is there in an object.

i. if two objects are having same data then their hashcodes will be same.

ii. if two objects are having different data then their hashcodes will be different.

--> a hashcode is generated based on data.

Note:
 --> Sun micro system has written the logic to generate hashcode number
     based on data in hashCode() method.

 --> hashCode() method returns hashcode which is generated based
     on data.

Q. what equals() method compares then?

Ans: equals() method compares hashcodes which are returned by hashCode() 
     method and hashCode() method generates and returns hashcode number 
     based on data so equals() method indirectly compares data but directly
     compares hashcodes.


class A   //super class
{
   void m1() {
   }
}

class B extends A  //sub class
{
}

B b = new B();
b.m1();
-------------------------------
class Object
{
  //11 methods  (equals())
}

class String extends Object
{
}

String s1 = "hello";
s1.equals();

-------------------------------------------------------------------------
Note:
 --> In a sub class if we dont override Object class hashCode() and equals() method
     and using sub class object if we call hashCode() and equals() methods then
     jvm calls Object class hashCode() and equals() method on that sub class object.

 --> In a sub class if we override Object class hashCode() and equals() methods
     and using sub class object if we call hashCode() and equals() methods then
     jvm calls sub class overridden hashCode() and equals() methods on that sub
     class object.

 --> Object class hashCode() method returns object reference number as hashcode
     number and Object class equals() method compares hashcodes which are returned 
     by Object class hashCode() methods.

 --> Sun micro system has not written the logic to generate hashcode number based
     on data in Object class hashCode() method because the data is not available
     in Object class but in its sub class.

 --> If we want hashCode() method of Object class to generate and return hashcode
     number based on data then we must have to override Object class hashCode()
     method in sub class by giving sub class data then hashCode() method generates
     hascode number based on data which is available in sub class object, whenever
     we override Object class hashCode() method in sub class along with hashCode()
     method we must have to override Object class equals() method also because 
     equals() method compares hashcodes which are generated and returned by hashCode().

finalize() :
----------
--> finalize() method is called by garbage collector before destroying or removing
    an object from jvm's heap area to execute some cleanup code only once.

syntax:
   protected void finalize()

what is object life cycle?

--> the entire process of object creation and till its destruction is called as
    object life cycle.

--> managing the birth of an object and managing the death of an object is called
    as object life cycle.

--> after object is created immediately initializing the instance variables of an
    object using constructor is called as managing the birth of an object.

--> before object is destroyed or removed executing some cleanup code by using 
    finalize() method is called as managing the death of object.

--> we manage object life cycle using constructor and finalize() method.

garbage collection :
------------------
--> it is a process of removing unused objects from jvm's heap area.

--> garbage collector is responsible to perform garbage collection.

how garbage collector knows which objects are in use and which objects are not
in use? 
                    (or)

how garbage collector knows which objects are eligible for garbage collection
and which are not eligible for garbage collection?

answer: if an object is not having any external reference then an object is eligible
        for garbage collection.

--> to make an object eligible for garbage collection assigns the reference variable
    as null.

--> garbage collector gets called automatically on every periodic time.

--> if garbage collector has to run then jvm must be running.

--> if main method execution is going on means jvm is running and once main method
    execution completes means jvm shutdown.

--> if jvm completes the execution of main method before the periodic time of
    garbage collector then jvm shutdown and garbage collector will not execute 
    and if garbage collector is not executed then finalize() method also will
    not be executed.

--> if we want to execute garbage collector before the periodic time and before
    jvm shutdown we have to use System.gc().

Note:
 --> if constructor is executed means object is created and available and if
     finalize() method is executed means object is destroyed or removed.


hashCode()  vs   equals()   vs    ==

class A
{
  int i = 10;
}

class B 
{
  int j = 10;
}

A obj1 = new A();
B obj2 = new B();

System.out.println(obj1.hashCode());

System.out.println(obj1 == obj2);    //c.e

System.out.println(obj1.equals(obj2));  //false


String :
------
--> It is a class in java.lang package.

--> String class is used to represent a group of characters (string or
    string literal) as an object.

                 (or)

--> to represent a string (which is a group of characters) into an object
    sun micro system has provided String class.

Note:
 --> every string literal is an object of String class in java.

--> a group of characters which are enclosed within double quotations
    is called as a string or string literal.
  
   ex:
     "hyderabad"  -->  string or string literal

Note:
 --> In String class which is also a sub class of Object class sun micro
     system has overridden Object class toString() method to return data
     as string.

Ways of creating a string :
-------------------------
1st way: using string literal and without new operator

2nd way: using new operator

3rd way: using character array and new operator

Methods Of String Class :
-----------------------
--> To perform operations on a string we use methods.

1. char charAt(int index)
2. int compareTo(String anotherString) : it compares two strings each 
                                         character's ascii value. 
3. int compareToIgnoreCase(String str)
4. String concat(String str)
5. boolean contains(String str)
6. boolean endsWith(String suffix)
etc



     ex:
        s1.compareTo(s2);

    --> if first string has to come before second string then compareTo
        method returns a -ve value.

    --> if first string has to come after second string then compareTo
        method returns a +ve value.

    --> if first string and second string are same then compareTo method
        returns '0'.

Note:
  --> In java, string also has index which also starts from '0' and the
      index of string is called as string index.

  --> If we perform any modification on a string always a new string
      object will be created with modified data but same string cannot
      be modified because String is immutable.

String
|- instance methods
|- static methods

--> String class contains several valueOf() methods which are static methods
    and valueOf() methods are used to convert any primitive type, any object
    and an array into String object.

String
|- String valueOf(int i)
|- String valueOf(float f)
|- String valueOf(double d)
|- String valueOf(boolean b)
|- String valueOf(Object o)
|- String valueOf(char[] ch)
   etc

Requirement-1:
  --> Write a program to accept a string and a character from keyboard and
      find the repeated characters in a string.

Requirement-2:
  --> Write a program to accept a string and check it is pangram or not.

Requirement-3:
  --> Write a program to count number of vowels in a string.


arif  and  rafi


afir   afir


a quick brown fox jumps over the lazy dog

------------------------------------------------------------------------
string comparison :
-----------------
--> comparing two strings data.

--> It is always recommended to compare two strings by using equals() method and
    equals() method always compare two strings data.

Note:
 --> String class maintains a pool of strings privately which is initially empty.

 --> Pool of strings is also called as String Constant Pool (SCP).

Immutability Of String :
----------------------

Is String is mutable or immutable?

--> String is immutable in java.

Note:
 --> If we modify a string then a new string object is created with
     modified data but same string object cannot be modified because
     string is immutable.

Mutable means can change

Immutable means cannot change

Note:
 --> If we want to modify a string then immutability of string is a 
     problem.

 --> To resolve the problem of immutability of String class sun micro 
     system has provided StringBuffer and StringBuilder.

StringBuffer & StringBuilder :
----------------------------
--> These are classes available in java.lang package.

--> StringBuffer and StringBuilder classes are same as String class 
    but String is immutable where as StringBuffer and StringBuilder
    are mutable.

StringBuffer :
------------
--> It is a class in java.lang package and it is same as String class but
    it is mutable.
--------------------------------------------------------------------------
	StringBuffer				StringBuilder
------------------------------------------------------------------------
1. it is synchronized.                 1. it is not synchronized.

2. it is thread safe.                  2. it is not thread safe.

3. performance is low.                 3. performance is high.

4. it is available from jdk 1.0v       4. it is available from jdk 1.5v
   onwards.                               onwards.
-------------------------------------------------------------------------
program-1: write a program to accept a file name, find extension of the
           file and display.

enter a file name : dbms.pdf

extension of file : pdf

program-2: write a program to accept a string.

   enter a string : computer
   output: r-e-t-u-p-m-o-c

java.lang
|- Object, String, StringBuffer, StringBuilder 

-------------------------------------------------------------------------
Inner Classes :
-------------
What is inner class?
--> a class which is declared inside another class is called as inner 
    class or nested class.

advantages :
----------
1. inner classes can access all the members of outer class including
   private members.

2. inner class is a security mechanism where we can provide security
   to an entire class by declaring private.

3. using inner classes we can place related classes in one place so
   that the classes become more readable and easily manageable.

Types of inner classes :
----------------------
--> There are 4 types of inner classes

1. member inner class
2. static inner class
3. local inner class
4. anonymous inner class

class A   //outer class
{
   private int i = 10;

   void m1() {
   }

   class B   //inner class
   {
   }
}


tcs -> project -> 30 employees

class A
class B
class C
class D
class E
.
.
.
.
.
5000 classes


class One
{
  //members
}

class Two
{
   One o;

   //members
}


modifiers


private class A   //c.e
{
  private int i = 10;

  private void methodOne() {
  }
}

static class A   //c.e
{
  static int i = 10;
  
  static void m1() {
  }

  static class B
  {
  }
}

1. member inner class :
   ------------------
--> a class which is declared inside another class as a member is called
    as member inner class.


class A   //outer inner class
{
   int i = 10;

   void m1() {
   }

   class B   //member inner class
   {
   }
}

B b = new B();  //c.e

--> we cannot create object to member inner class without creating object to outer
    class.

--> to create inner class object, outer class object is mandatory. 

--> using outer class object only we can create inner class object.

syntax:
   OuterClassName.InnerClassName objName = outerClassObj.new InnerClassName();

class A   //outer inner class
{
   int i = 10;

   void m1() {
   }

   class B   //member inner class
   {
   }
}

A obj1 = new A();
A.B obj2 = obj1.new B();

static inner class :
------------------
--> an inner class which is declared using static keyword is called as static 
    inner class.

syntax:
  OuterClassName.StaticInnerClassName objName = new OuterClassName.StaticInnerClassName();

class A
{
   int i = 10;  

   void m1(){
   }

   static class B    //static inner class
   {
     
   }
}

Note:
 --> If outer class contains instance members (instance variables and instance 
     methods) then we cannot access instance members of outer class inside static
     inner class directly, in this case dont use static inner class better use 
     member inner class.

 --> If outer class does not contain any instance members or it contains only
     static members then use static inner class.

 --> static inner class can have instance members and to access instance members
     of static inner class we must have to create object to static inner class.

 --> if static inner class contains only static members then we no need to create
     object to static inner class, we can access static members of static inner 
     class using OuterClassName.InnerClassName.memberName.

local inner class :
-----------------
--> a class which is declared inside any method or a constructor of a class such
    class is called as local inner class.

--> we can create object to local inner class and access local inner class object
    inside the same method where local inner class is declared.


class One
{
   static
   {
      static
      {
        static
        {
          Sopln("hello");
        }
        Sopln("hi");
      }
      Sopln("bye");
   }
}

public class Test
{
   public static void main(String[] args)
   {
     One o = new One();
   }
}

java Test

anonymous inner class :
---------------------
--> an inner class without a name is called as anonymous inner class.

--> only one object can be created to an anonymous inner class.

OOP's Concepts :
--------------
1. Class and Object
2. Data Hiding
3. Abstraction
4. Encapsulation
5. Inheritance (Is-A Relationship)
6. Composition (Has-A Relationship)
7. Polymorphism

Inheritance :
-----------
--> creating or deriving new classes from the existing classes so that
    new classes acquire all the properties of existing classes is called
    as inheritance.

--> inheritance establishes is-a relationship between the classes which
    is called as parent-child relationship.

--> in java, extends keyword is used in inheritance.

--> the advantage of inheritance is reusability of code.

Note:
 --> In inheritance, it is always recommended to create object to sub 
     class because sub class has sub class and super class properties
     so using sub class object we can access both super class and sub
     class properties.

 --> In inheritance when we create object to sub class by calling sub
     class constructor then jvm creates sub class object by calling
     sub class constructor to initialize sub class members and sub 
     class constructor internally calls super class zero parameterized
     constructor to initialize super class members.


java.lang
|- Object
   |- 11 methods
      - Class getClass()
      - int hashCode()
      - String toString()

class One
{
   String str = "hello";

   public String toString() {   //overridden method
     return str;
   }
}

One obj = new One();
System.out.println(obj.toString());  //hello

--> whenever we use any object on every object by default jvm internally
    calls toString() method.


super keyword :
-------------
--> super is a keyword in java, if super class and sub class having members with same name then to access or refer to super class members
from sub class we use super keyword.

i. super keyword can be used to access or refer to super class instance
   variables from sub class

   syntax:
     super.instanceVarName;

ii. super keyword can be used to access or refer to super class instance
    methods from sub class

    syntax:
      super.instanceMethodName();

iii. super keyword can be used to access or refer to super class cons-
     tructors from sub class constructors

     syntax:
       super();   or    super(parameters);


class A
{
   int i;

   void m1() {
   }
}

class B extends A
{
   int i;

   void m1() {
     this.i or i
     super.i
     m1() or this.m1();
     super.m1();
   }
}
--------------------------------------
class A
{
   void m1() {
     Sop("super m1");
   }
}
class B extends A
{
  void m2() {
     m1(); or this.m1();
     Sop("sub m2");
  }
}

B b = new B();
b.m2();
---------------------------------------
class A
{
   void m1(){
   }

   void m2(){
     m1(); or this.m1();
   }
}

A a = new A();
a.m2();
--------------------------
class A
{
   void m1(){
   }
}

class B
{
   void m2() {
     A a = new A();
     a.m1();
   }
}

B b = new B();
b.m2();
-------------------------------------------------------------------------
types of inheritance :
--------------------
--> there are 2 types of inheritance

    1. single inheritance
    2. multiple inheritance

------------------------------------------------------------------------
class A
{
  void m1(){
  }
}

class B extends A
{
   void m2() {
   }
}

B b = new B();  //valid
b.m1();
b.m2();

A a = new B();  //valid
a.m1();
a.m2();  //c.e

Object o = new B();

Object o = new A();

--> To access super class and sub class members we need not only sub class
    object but also sub class reference variable.


-----------------------------------
class A
{
  void m1(int i){
  }
}

class B extends A
{
   void m1() {
   }
}

B b = new B();
b.m1();
b.m1(10);

Polymorphism
------------
--> Poly means many
    morphs means behaviours (forms)

--> Polymorphism means many forms

what is polymorphism?
--> one thing showing or having many behaviours is called as polymorphism.

there are 2 types of polymorphism

1. compile time or static polymorphism

   --> the polymorphism which is shown at compilation time by the compiler
       is called as compile time or static polymorphism.

       ex: method overloading, method hiding

2. runtime or dynamic polymorphism

   --> the polymorphism which is shown at runtime by the jvm is called
       as runtime or dynamic polymorphism.
  
       ex: method overriding

method signatures :
-----------------
--> method name with parameters is called as method signature.

Method Overloading :
------------------
--> writing two or more methods in a class with same name but with 
    different method signatures is called as method overloading and
    such methods are called as overloaded methods.

Note:
 --> in method overloading which is an example of compile time or static
     polymorphism method resolution is resolved by compiler at compition 
     time by using reference variable.

 --> here reference variable is playing the major role where as object
     is dummy.

Note:
 --> method signatures difference must be :
     i. number of parameters
     ii. type of parameters
     iii. order of parameters

class A
{
   void m1() {
   }

   void m1(int a) {
   }
  
   void m1(float b) {
   }

   void m1(int a, float b) {
   }

   void m1(float a, int b) {
   }  
}

what is method resolution?
--> resolving a method call either by compiler or jvm is called as
    method resolution.


1)
class One
{
   public void methodOne(byte b) {
      System.out.println("from methodOne(byte)");
   }

   public void methodOne(int i) {
      System.out.println("from methodOne(int)");
   } 
}

public class MethodOverloadingExample2
{
   public static void main(String[] args)
   {
       One o = new One();
       o.methodOne((byte)10);
   }
}

2)
class One
{
   public void methodOne(String str) {
      System.out.println("from methodOne(String)");
   }

   public void methodOne(StringBuffer sb) {
      System.out.println("from methodOne(StringBuffer)");
   } 
}

public class MethodOverloadingExample2
{
   public static void main(String[] args)
   {
       One o = new One();
       o.methodOne(null);
   }
}

method overriding :
-----------------
--> overriding super class method in sub class with different implementa-
    tion is called as method overriding.

rules for method overriding :
---------------------------
1. method name and parameters must be same.

2. return type also must be same but this rule is applicable upto jdk 
   1.4 but from jdk 1.5 onwards co-variant return-types are allowed.

Note:
 --> In method overriding which is an example of dynamic or runtime
     polymorphism method call is resolved (method resolution) by jvm
     at runtime using object.

 --> Here object plays the major roles where as reference variable is
     dummy.

Note:
 --> In method overriding we have to use super class reference variable
     to hold sub class object to show runtime or dynamic polymorphism.

class A
{
  void m1() {    //overriding method
    //addition of two numbedrs
  }
}

class B extends A
{
   void m1() {   //overridden method
     //multiplication of two numbers
   }
}

co-variant return types :
-----------------------
--> super class overriding method return type need not be same as sub 
    class overridden method return type they can be different this is
    called co-variant return types.

Note:
 i. co-variant return types are not allowed for primitive datatypes.

 ii. co-variant return types are allowed only for object types (classes).

 iii. in co-variant return types inheritance relationship must be there.

 iv. in co-variant return types the order must be parent to child but
     not child to parent.


--> scope means accessibility (who can access, where can access)

    public > protected > default > private

--> public has highest scope and private has least scope.

--> in method overriding we can use the same scope or we can increase
    the scope of a method but we cannot decrease the scope of a method.

--> we cannot override super class private method in sub class as they
    are not inherited in sub class.

--> super class final methods cannot be overridden in sub class.

--> we cannot override super class static methods as non-static or
    instance methods in sub class.

--> we can override super class static method in sub class as static 
    method.

method hiding :
-------------
--> overriding super class static method in sub class as static method
    is called as method hiding.

--> in method hiding super static method is hidden to sub clas static 
    method.

Note:
 --> The rules for method hiding is same as rules for method overriding.

 --> In method hiding which is an example of compile time or static
     polymorphism the method call is resolved by (method resolution) 
     compiler at compilation time using reference variable.

ex:
class One
{
   public static void methodOne() {
     System.out.println("super class methodOne");
   }
}

class Two extends One
{
   public static void methodOne() {
     System.out.println("sub class methodOne");
   }
}

public class MethodOverridingExample2
{
   public static void main(String[] args)
   {
        //Two t = new Two();
        One o = new Two();
        o.methodOne();
   }
}

what is early binding?

--> when we call a method, a method call is generated internally and 
    the method call is binded with appropriate method body at compila-
    tion time this is called as early binding.

Note:
 --> early binding happens in compile time or static polymorphism.

what is late binding?

--> when we call a method, a method call is generated internally and 
    the method call is binded with appropriate method body at runtime 
    this is called as late binding.

Note:
 --> late binding happens in runtime or dynamic polymorphism.

 --> We can overrload methods and constructors.

 --> We cannot override constructor but we can override method.

Abstract Classes :
----------------
--> Abstract class is one the abstraction mechanism in java.

what is an abstract class?
--> a class which contains atleast one abstract method is called as
    abstract class.

--> an abstract class can have non-abstract methods also.

what is a non-abstract method?
--> a method which has both method header or method prototype and method
    body or implementation is called as non-abstract method.

--> non-abstract method is a complete method.

what is an abstract method?
--> a method which has only method header or method prototype is called
    as abstract method.

--> abstract method is a incomplete method.

what is a concrete class (complete class)?
--> a class which contains only non-abstract methods is called as
    concrete class.

Note:
 --> a concrete class will not have any abstract methods.

 --> abstract is a keyword and a non-access modifier which is allowed
     only for methods and classes.
  
 i. an abstract method must be declared using abstract keyword.

 ii. a class which contains atleast one abstract method then that class
     also must be declared using abstract keyword.

 iii. we cannot create object to an abstract class.

 iv. the only way to use an abstract class is by using inheritance.

 v. abstract class can instance variables, static variables and 
    constructors also.

------------------------------------------------------------------
class One
{
  abstract void m1();
  void m2() {
  }
}

class Two extends One
{
   void m1() {
   }
}

public class Three
{
   public void m3(One o) {
   }
}

class Four
{
  public static void main(String args[])
  {
    Three th = new Three();
    Two t = new Two();
    th.m3(t);
  }
}
------------------------------------------------------------------------
class One
{
  abstract void m1();
  void m2() {
  }
}

class Two extends One
{
   void m1() {
   }
}

public class Three
{
   public One m3() {
      One o = new Two();
      return o;
   }
}
------------------------------------------------------------------------
interfaces :
----------
what is an interface?
--> any service requirement specifications (srs) is considered as an
    interface.

what is service requirement specifications (srs)?
--> from service provider point of view an interface defines the set of
    services or features which are offering those services or features
    are called as service requirement specifications.

--> from client point of view an interface defines the set of services 
    or features which are expecting those services or features are called
    as service requirement specifications.

--> any contract between two people is also called as an interface.

--> interfaces are used to show only the services or features which are
    offering and expecting but interfaces are not used to show their 
    implementation logic thats why interfaces contain only method headers
    or prototypes but not implementation indirectly abstract methods.

--> a class which contains only abstract methods is called as 100% incom-
    plete class and 100% incomplete class becomes an interface.

--> a 100% incomplete class is called as an interface.

what is an interface?
--> any service requirement specifications or a contract between two 
    people or a 100% incomplete class is called as an interface.
-------------------------------------------------------------------------
syntax for creating an interface :
--------------------------------
syntax:
  modifier interface InterName
  {
     //only abstract method
  }

Note:
 i. by default all the methods of an interface are public and abstract.

 ii. the only modifiers which are allowed for the methods of an interface
     are public and abstract.

 iii. object cannot be created to an interface.

 iv. to use interface we create implementation class using implements
     keyword and in implementation class we must have to override and
     provide the implementation to all the abstract methods of an    
     interface.

 v. a class which provides the implementation to all the abstract methods
    of an interface is called as implementation class.

 vi. extends keyword establishes is-a relationship between sub class and
     super class in the same way implemetns keyword also establishes 
     is-a relationship between implementation class and interface.

 vii. as every sub class is not only sub class type as well super class
      type in the same way every implementation class is not only imple-
      mentaion class type but also interface type.

 viii. we can create object to an implementation class of an interface.

 ix. we cannot create object to an interface but we can create reference
     variable to an interface and using interface reference variable we
     can hold any of its implementation class object.

 x. we can write variables inside an interface but at the time of decla-
    ration we must have to initialize.

 xi. by default all the variables of an interface are public, static and
     final.

 xii. the only modifiers which are allowed for variables of an interface
      are public, static and final.

 xiii. the purpose of declaring variables inside an interface is to 
       define static constant variables.

 xiv. the variables of an interface we can access directly in implementa-
      tion classes or using interface name directly.

-----------------------------------------------------------------------
interface IA {
  void m1();
}
class A implements IA {
  void m1(){
  }
}
class B
{
   void m2(IA obj) { 
      obj.m1();
   }
}

B b = new B();
IA obj = new A();
b.m2(obj);

Note: 
--> if a method is having an interface reference variable as a parameter
    then to call that method we have to create object of that interface
    implementation class and pass.

------------------------------------------------------------------------
interface IA {
  void m1();
}
class A implements IA {
  void m1(){
  }
}
class B
{
   public static IA m2() { 
      IA obj = new A();
      return obj;
   }
}

IA obj = B.m2();

Note:
 --> If a method is having an interface as return type then that method
     should create and return the object of that interface implementation
     class.
------------------------------------------------------------------------

Marker Interfaces : (tagged interfaces or ability interfaces)
-----------------
--> an interface which contains 0 abstract methods is called as marker
    interface.

Note:
 --> Marker interface will not have any variables also.

--> In java, there are several predefined marker interfaces are available.

ex: 
  Cloneable
  Serializable
  RandomAccess

--> Marker interfaces act as meta-data (information) for the jvm which 
    means using marker interfaces we can give some information to jvm
    to add some ability to an object of a class.

Note:
 --> By default an object of a class will not have some abilities.

 --> cloning is one ability, serialization is one ability etc

ex:
  class Employee implements Cloneable
  {
  }
-------------------------------------------------------------------------
packages :
--------
--> package is a mechanism of encapsulating or binding related classes,
    interfaces and sub packages in one place together.

--> packages are used to make class names unique because of which we can
    avoid naming collision or naming conflicts.

--> searching or finding the classes become easy if use packages.

--> we can control the scope of classes, interfaces, methods etc using
    packages.

--> a package looks similar to a folder in a computer and a package 
    contains class files (.class files).

creating a package :
------------------
syntax:
  package package-name;

creating sub package :
--------------------
syntax:
  package package-name.sub-package-name1.sub-package-name2;


person-1
--------
package p1;

class Employee{      fully qualified name of the class 
}                             
                             p1.Employee
person-2
--------
package p2;

class Employee{		     p2.Employee
}

person-3
--------
package p3;                  p3.Employee

class Employee{
}


naming convention for packages :
------------------------------
com.project-name.module-name.sub-module-name.role.ClassName


compiling a class which is placed inside a package :
--------------------------------------------------
syntax:
  javac -d location ClassName.java

-----------------------------------------------------------------------
package com.onlinecalculator.arithmetic;

class Calculator
{
   public int add(int a, int b) {
     return a + b;
   }
}

d:\work
   |- Calculator.java
   |- TestCalculator.java
   |- com
      |- onlinecalculator
         |- arithmetic
            |- Calculator.class
  

d:\work>javac -d . Calculator.java

class TestCalculator
{
   public static void main(String[] args)
   {
      Calculator cal = new Calculator();
   }
}

d:\work>javac TestCalculator.java

-----------------------------------------------------------------------------------
d:
|- work
   |- com\fungames\racing\Game.class
   |- TestGame.java  (it is using Game class)
   |- TestGame.class
-------------------------------------
package com.fungames.racing;

public class Game {
  public void play() {
    System.out.println("playing..");
}

d:\work>javac -d . Game.java
---------------------------------------
import com.fungames.racing.Game;

public class TestGame
{
   public static void main(String args[])
   {
      //com.fungames.racing.Game game = new com.fungames.racing.Game();
      Game game = new Game();
      game.play();
   }
}

d:\work>javac TestGame.java   //it works

d:\work>java TestGame  //it works



import java.util.Scanner;

class Test
{
   public static void main(String[] args)
   {
      //java.util.Scanner sc = new java.util.Scanner(System.in);

      Scanner sc = new Scanner(System.in);             
   }
}
------------------------------------------------------------------------
d:\work\TestGame.java  (TestGame class is using Game class)

e:\temp\Game.class

in command prompt :
-----------------
d:\work>javac TestGame.java  //it will not work

--> To resolve above problem we have to change or set the classpath.

2's way : at command prompt level
-------
d:\work>set CLASSPATH=e:\temp

--> now compiler and jvm search for all class files in classpath location

d:\work>javac TestGame.java
  
--> it works and TestGame.class is generated

d:\work>java TestGame  //error: could not load main class TestGame

--> to resolve above problem set classpath to both the class files location

d:\work>set CLASSPATH=e:\temp;d:\work (or) set CLASSPATH=e:\temp;.

d:\work>javac TestGame.java  //it works

d:\work>java TestGame  //it works

1st way: at command level 
-------
d:\work>javac TestGame.java  //compile time error: cannot find symbol

d:\work>javac -cp e:\temp TestGame.java  //it works

d:\work>java -cp e:\temp;d:\work TestGame  //it works

               (or)

d:\work>javac -classpath e:\temp TestGame.java  //it works

d:\work>java -classpath e:\temp;d:\work TestGame  //it works
     
3rd way: at operating system level
-------
--> if we set classpath at os level it is permanent but it is not recommended.



here current directory location  -->  d:\work

Note:
 --> By default java compiler and jvm search for class files (.class files) in
     the current directory location which is also called as default classpath.

what is CLASSPATH?
--> CLASSPATH is a system variable or an environment variable which is used by java
    compiler and jvm to search for the location of required class files (.class files).

Note:
  --> If we dont set any CLASSPATH system variable or environment variable then the
      default CLASSPATH location is current directory.


-------------------------------------------------------------------------------------
Important Points :
----------------
1. if the class file (.class file) is available inside a package then we have to use 
   either fully qualified name of the class or import the package.

2. if the class file (.class file) is not available in current directory location and
   if it is there in different directory location then we have to set classpath. 

package models :
--------------
--> in java, there are 3 packaging models

1. jar  (java archive)

--> for core java applications we have to jar packaging.

--> a jar contains .class files.

--> a jar ends with .jar extension.

2. war (web archive)

--> for web applications we have to use war packaging.

--> a war contains .html, .jsp, .js, .css, .jpg, .png, .class, and .jar files.

--> a war ends with .war extension.

3. ear  (enterprise archive)

--> for enterprise web applications we have to use ear packaging.

--> an ear contains several wars.

--> an ear ends with .ear extension.


project
|- multiple classes --> package into single file

--> jar is a tool (development tool) in java and it is used to create jar, war and ear.

--> archive means a jar or a war or an ear.

creating a jar :
--------------
syntax:
  jar -cvf some-name.jar *.class

to see the contents of a jar :
----------------------------
syntax:
  jar -tvf some-name.jar

extracting a jar :
----------------
syntax:
  jar -xvf some-name.jar

Note:
 --> A jar is also a logical directory location.

 --> If the required .class file is there in a jar then we must have to set the class-
     path to jar.

---------------------------------------------------------------
e:\temp\app1.jar (Rocket.class)

d:\work\Test.java (Test class is using Rocket class)
d:\work\Test.class

in command prompt:
-----------------
d:\work>javac Test.java

1st way:  d:\work>javac -cp e:\temp\app1.jar Test.java
-------   
          d:\work>java -cp e:\temp\app1.jar;. Test


2nd way:   d:\work>set CLASSPATH=e:\temp\app1.jar;.
--------
           d:\work>javac Test.java

           d:\work>java Test

-----------------------------------------------------------------------------------
File IO :
-------
1. File
2. FileReader
3. FileWriter
4. BufferedReader
5. BufferedWriter
6. PrintWriter

--> all the above classes coming from java.io package.

File :
----
--> It is a class in java.io package.

--> File class object represents file pathnames or directory pathnames.

--> If file or directory is available then File class object also points to that 
    file or directory.


d:
|- work (directory)
   |- abc.txt (file)

d:\work -->  directory pathname

d:\work\abc.txt  -->  file pathname

----------------------------------------------------------------------------------
program-1: write a java program to create a directory and inside the directory
           create a file.

notes 
|- dbms.txt

program-2: write a java program to display all the sub directories and files 
           which are available in a directory.

btech
|- firstsem
|- secondsem
|- thirdsem
|- dbms.txt
|- clang.txt
|- data-structures.txt
|- cpp.txt
|- computer-networks.text

program-3: write a program to count sub directories and files in a directory.

FileReader :
----------
--> It is a character stream and it is used to read character data from a file
    character by character.

Note:
 --> To improve the performance of FileReader we can use BufferedReader.

FileWriter :
----------
--> It is a character stream and it is used to write character data to a file
    character by character.

--> it writes one character to a file at a time which impacts performance.

Note:
 --> to improve the performance of FileWriter we have to use BufferedWriter.

PrintWriter :
-----------
--> It is a character stream and it is used to write characters and primitive
    values.

serialization and deserialization
---------------------------------
what is serialization?

--> the process of converting the state of an object into bits or bytes i.e.,
    binary representation is called as serialization.

			(or)

--> the process of converting java supported format into network supported format
    is also called as serialization.

ex:
  ObjectOutputStream
  |- void writeObject(Object o)
   
  FileOutputStream

what is deserialization?

--> the process of converting the bits or bytes i.e., binary representation into
    an object is called as deserialization.

			(or)

--> the process of converting network supported format into java supported format
    is also called as deserialization.

ex:
  ObjectInputStream
  |- Object readObject()

  FileInputStream

transient :
---------
--> transient is a keyword and a non-access modifier in java and it is allowed
    only for variables.

--> if we declare any state using transient keyword then that state will not
    participate in serialization and deserialization.

Note: 
 --> for local variables transient keyword is not allowed.

transient vs static 
-------------------
--> static variables will not participate in serialization and deserialization 
    because they are not part of object so declaring static variable using 
    transient keyword there is no use.

transient vs final 
------------------
--> final variables will participate directly in serialization and deserialization
    so declaring final variables using transient keyword there is no use.

exception handling :  
------------------
what is exception?
--> an exception is an event (action) which is raised during the execution of a
    program and which distrupts the normal flow of execution.

                      (or)

--> whenever any unwanted or unexpected event is raised in a program due to which
    the smooth execution of a program is interrted that event is called as an 
    exception.

what is exception handling?

--> exception handling is a mechanism of providing altenate way or alternate path
    for the exception so that the normal flow of execution is not interrupted.

what is the difference exception and error?

--> exceptions are caused due to java programs and exceptions are recoverable.

--> errors are caused due to the lack of system resources and errors are not
    recoverable.

Note:
 --> All exceptions are runtime errors only.

 --> All exceptions and errors are classes in java.

Types of exceptions
-------------------
--> There are 2 types of exceptions

    1. checked exceptions
    2. unchecked exceptions

--> the exceptions which are checked or reported by the compiler at compilation
    time for smooth execution of a program at runtime and which are recoverable
    are called as checked exceptions.

--> the exceptions which are not checked or reported by the compiler at compila-
    tion time, which are raised directly at runtime and which are not recoverable
    are called as unchecked exceptions.

--> Checked exceptions are 2 types

    1. partially checked
    2. fully checked

--> if parent is checked, some children are checked and some children are
    unchecked such exceptions are called as partially checked.

    ex: Exception and Throwable

--> if parent is checked and all children are also checked such exceptions 
    are called fully checked.

     ex: IOException


--> default exception handler

--> There are 2 ways to handling checked exceptions

    1. using try and catch
    2. using throws keyword

--> If we dont want to handle an exception because we dont have any handling code
    or alternate path in that case simply we can delegate (pass) the responsibility
    of handling a check exception to the caller of a method where checked excep-
    tions are reporting by declaring exceptions to throws to that method.

--> There is only one way to handle unchecked exception 
  
    1. using try and catch

-----------------------------------------------------------------------------
try catch workflow :
------------------
stmt-1;   
stmt-2;  
try
{
  stmt-3;  
  stmt-4;   
}
catch(Exception e)
{
  stmt-5;  
  stmt-6;  
}
stmt-7;   
stmt-8;

try :
---
--> it is used to write risky code.

catch :
-----
--> it is used to write handling code.

finally :
-------
--> it is used to write cleanup code.

methods to display exception information
----------------------------------------
1. void printStackTrace()  	-	Throwable

--> it displays 3 informations

    i. name of the exception
    ii. description of the exception
    iii. stack trace

2. String getMessage()		-	Throwable

--> it displays 1 information

    i. description of the exception

3. String toString()		-	Throwable

--> it displays 2 informations

    i. name of the exception
    ii. description of the exception


throws :
------
--> it is a keyword, if we dont want to handle a checked exception simply we want
    to delegate (pass or give) the responsibility of handling a checked exception
    to the caller of a method then use throws keyword to declare that exception to
    that method.

--> throws keyword is used to declare only checked exceptions.

throw :
-----
--> it is a keyword, if we want to create and throw an exception object explicitly
    we use throw keyword.

syntax:
    throw exceptionObj;


try with resources :
------------------
--> it is a new feature added in java 1.7 onwards, if we use this feature then
    automatically jvm closes system resources we no need to write finally block.


context switching
address space
dependency
synchronization
resource consumption
time or creation
time for termination

multi-threading 
---------------
what is multi-tasking?
--> executing more than one task simultaneously is called as multi-tasking.

types of multi-tasking :
----------------------
--> there are 2 types of multi-tasking

1. process based multi-tasking
2. thread based multi-tasking

what is process based multi-tasking?
--> executing more than one task simultaneously where each task is a seperate
    independent process is called as process based multi-tasking.

what is thread based multi-tasking?
--> executing more than one task simultaneously where each task is a seperate
    independent part of the same process is called as thread based multi-tasking.

what is a process?

--> a program which is executing is called as a process.

what is a thread?

--> a thread is a sub-part of a process.

--> a thread is a light weight process.

--> an independent path of execution of a process is called as thread.

--> one flow of execution of a process is also called as a thread.

what is single threading?
--> executing one thread is called as single threading.

what is multi-threading?
--> executing more than one thread simultaneously is called as multi-threading.

advantages of multi-threading
-----------------------------
--> multi-threading reduces response time and improves performance.

---------------------------------------------------------------------------------------
--> By default in every java program one thread will be available which is created by
    jvm and who executes the java program means main method whose name is main thread.

--> In java, everything is represented as classes or objects so a thread is also a class
    or an object in java.

--> To work with multi-threading in java, sun micro system has provided multi-threading
    api.

--> Thread class and Runnable interface represent multi-threading api and Thread class
    and Runnable interface are belonged to java.lang package.

java.lang
|- Thread
   |- public static Thread currentThread() : it returns the reference of current 
                                             executing thread.

ways of creating a thread (user thread)
---------------------------------------
--> there are 2 ways of creating a thread

1. creating a thread by extending Thread class

2. creating a thread by implementing Runnable interface

creating a thread by extending Thread class :
-------------------------------------------
step-1: develop a class which extends Thread class.

step-2: override run() method to define the task/job a thread.

step-3: create object to a class which extends Thread class.

step-4: call start() method to execute a thread.

creating a thread by implementing Runnable interface :
----------------------------------------------------
step-1: develop a class which implements Runnable interface.

step-2: override run() method to define the task of a thread.

step-3: create object to a class which implements Runnable interface.

step-4: create object to Thread class by passing runnable class object.

step-5: call start() method to execute a thread.
----------------------------------------------------------------------------------
Note:
 --> A class which implements Runnable interface is not a thread class but it is
     a runnable class.


internal code of Thread class 
-----------------------------
public class Thread implements Runnable
{
    int priority = 5;              
    String name = "main";
    boolean isDaemon = false;
    etc

    Runnable r;

    public Thread() {
    }

    public Thread(Runnable r) {
      this.r = r;
    }

    public Thread(Runnable r, String name) {
      this.r = r;
      this.name = name;
    }

    public Thread(String name) {
       this.name = name;
    }
    etc

    public void run()
    {
       if(r != null) {
         r.run();
       }
    }

    public final int getPriority() {
    }
    public final void setPriority(int priority) {
    }

    public final void setName(String name) {
    }
    public final String getName() {
    }

    public static void yield() {
    }
    public static void sleep(long ms) {
    }
    public void join() {
    }
    etc 

    public void start() {
    }
    public void stop() {
    }
    public boolean isAlive() {
    }

    etc
}

setting and getting thread names :
--------------------------------
--> every thread has a name, either that name is assigned by jvm automatically or it
    is assigned by the programmer manually.

java.lang
|- Thread
   |- public final void setName(String name) : it sets the name for the thread.
   |- public final String getName() : it returns the name of the thread.

thread priorities :
-----------------
--> every thread in java has some priority, either the priority can default priority
    that is 5 or it can be assigned by the programmer.

--> thread schedular uses thread priorities in order to allocate cpu for a thread, a
    thread whose thread priority is high will execute first and a thread whose thread
    priority is low will execute last.

--> thread priority range must be between 1 to 10 where 1 is lowest thread priority and
    10 is highest thread priority.

--> if we use any priority other than 1 to 10 then jvm throws IllegalArgumentException.

--> in Thread class sun micro system has provided some static constant variables to
    represent standard thread priorities

    ex:  MIN_PRIORITY
         NORM_PRIORITY
         MAX_PRIORITY

java.lang
|- Thread
   |- public final void setPriority(int priority): it changes the priority of a thread.
   |- public final int getPriority(): it returns the priority of a thread.

methods to prevent thread execution :
-----------------------------------
1. yield()
2. join()
3. sleep()

yield() :
-------
--> it causes current executing thread to go to waiting state or temporary pause 
    for giving chance to other waiting threads which are having same priority.

--> if waiting threads are having low priority then same thread resume execution.

--> if waiting threads having having same priority then thread schedular decides
    which threads should get cpu.

syntax:
  public static void yield()

join() :
------
--> it makes a thread to wait until other thread die.

syntax:
  public final void join() throws InterruptedException

sleep() :
-------
--> it causes current executing thread to go to sleep (temporary stop execution) for
    some miliseconds.

syntax:
   public static void sleep(long millis) throws InterrupteException

----------------------------------------------------
interrupt() ---->  assignment


Non-synchronization :
-------------------
--> Allowing multiple threads to execute the methods on a single object at the same time is called
    as non-synchronization.

Note:
 --> If multiple threads execute the methods on a single object and if the object contains any data
     then the data which is there inside an object is shared between multiple threads which can lead
     to data inconsistency problem, so in non-synchronization there is a chance of data inconsistency
     problem.

How to resolve data inconsistency problem?
--> using synchronization (thread synchronizaton).

synchronization : (thread synchronization)
---------------
--> synchronized is a keyword (non-access modifier) in java and it is allowed only for methods and
    blocks.

--> any method or a block which is declared using synchronized keyword is called as synchronized method 
    or synchronized block.

--> when we declare any method or a block of a class using synchronized keyword then a thread who gets
    the cpu will acquire the lock of an object for executing all the synchronized methods and synchro-
    nized blocks meanwhile other threads have to wait.

--> once a thread who acquires the lock complete the execution of synchronized methods and synchronized
    blocks releases the lock then one the waiting thread acquires the lock.

--> waiting threads are not allowed to execute the synchronized methods and synchronized blocks but
    waiting threads are allowed to execute non-synchronized methods and blocks.

Note:
 --> in synchronization waiting time of threads increases.

 --> we can decrease the waiting time of threads by using synchronized block.

 --> there are two types of locks a thread can acquire

     1. object lock (object level lock)
     2. class lock (class level lock)

--> a thread will acquire the lock of an object if we declare instance methods or instance blocks
    using synchronized keyword.

--> a thread will acquire the lock of a class if we declare static methods or static blocks using
    synchronized keyword.

Note:
 --> if a thread has acquired the lock of an object means a thread is the owner of that object or
     a thread is monitoring that object.

 --> in non-synchronization as multiple threads are allowed to execute the methods on a single object
     at a time so in this case an object is said to be not thread safe but in synchronization only 
     one thread is allowed at a time to execute the methods on a single object so in this case an
     object is said to be thread safe.


deadlock :
--------

starvation :
----------

daemon thread :
-------------

Thread
|- boolean isDaemon()
|- void setDaemon(boolean)

volatile 
--------------------------------------------------------------------------------------------------
Collections :
-----------
What is a collection?
--> a collection is an object and a collection is used to represent a group of 
    other individual objects as a single entity.

collection framework :
--------------------
--> it provides set of classes and interfaces which can be used to represent a 
    group of individual objects as a single entity.

Note:
 --> collections chapter contains 9 key interfaces.

Interfaces :  (collection interfaces)
----------
1. Collection
2. List
3. Set
4. SortedSet
5. NavigableSet
6. Queue
7. Map
8. SortedMap
9. NavigableMap

--> All the above are interfaces available in java.util package and which are
    provided by sun microsystems and sun microsystems itself has provided imple-
    mentation classes to all the 9 interfaces.

1. Collection :
   ----------
   --> it is the root interface in collection hierarchy.

   --> it contains several methods which are common to all the collection in 
       collection hierarchy.

   --> if we want to represent a group of other individual objects as a single
       entity then go for Collection interface.

2. List :
   ----
   --> it is a sub interface of Collection interface.

   --> if we want to represent a group of individual objects as a single entity
       where duplicates are allowed and insertion order is preserved then go for
       List interface.

3. Set :
   ---
   --> it is a sub interface of Collection interface.

   --> if we want to represent a group of individual objects as a single entity
       where duplicates are not allowed and insertion order is not preserved
       then go for Set interface.

4. SortedSet :
   ---------
   --> it is a sub interface of Set interface.

   --> if we want to represent a group of individual objects as a single entity
       where duplicates are not allowed, insertion order is not preserved and
       elements should be stored according to some sorting order then go for
       SortedSet.

5. NavigableSet :
   ------------
   --> it is a sub interface of SortedSet interface.

   --> it provides several methods for navigation purpose.

6. Queue : 
   -----
   --> it is a sub interface of Collection interface.

   --> if we want to represent a group of individual objects as prior to process-
       ing then go for Queue.

7. Map :
   ---
   --> Map is an interface.

   --> if we want to represent a group of individual objects as key and value pair
       then go for Map interface.

8. SortedMap :
   ---------
   ---> it is a sub interface of Map interface.

   --> if we want to represent a group of individual objects as key and value pair
       and with some sorting order of keys then go for SortedMap.

9. NavigableMap :
   ------------
   --> it is a sub interface of SortedMap interface.
 
   --> it provides several methods for navigation purpose.

Methods Of Collection Interface
-------------------------------
1. boolean add(Object element)
2. boolean addAll(Collection c)
3. void clear()
4. boolean contains(Object o)
5. boolean isEmpty()
6. Iterator iterator()
7. boolean remove(Object o)
8. boolean removeAll(Collection c)
9. int size()
10. Object[] toArray()


https://global.gotomeeting.com/join/190977165


web server 
application server (jee server)

eclise ide
|- Java EE perspective (default perspective) --> web applications
|- Java perspective --> core java application

what is an array?
--> an array is an indexed collection of fixed number of homogeneous elements.

what is a collection?
--> a collection is an object and it is used to represent a group of other 
    individual objects as a single entity.

disadvantages of arrays :
-----------------------
1. arrays are fixed in size which means once we created an array we cannot increase
   or decrease the size of array at runtime according our convenient.

2. arrays store only homogeneous elements but not heterogeneous elements but this
   problem of arrays can be resolved in java using Object[].

3. as arrays are not implemented using any data structure thats why arrays will not
   provide any readymade methods support.

advantages of collections :
-------------------------
1. collections are growable in nature which means at runtime dynamically the size
   of collections will grow.

2. collections store both homogeneous and heterogeneous elements.

3. as collections are implemented using some data structure thats why collections
   provide readymade methods support.

-------------------------------------------------------------------------------------
		arrays				   collections
-----------------------------------------------------------------------------------
1. fixed in size.			    1. growable in nature.

2. stores only homogeneous elements         2. stores both homogeneous and hetero-
   but this problem can be resolved            geneous elements.
   in java using Object[].

3. readymade methods support is not there.  3. readymade methos support is there.

4. stores primitive values and objects.     4. stores only objects.

5. memory point of view arrays are not      5. memory point of view collectins are
   recommended to use.                         recommended to use.

6. performance wise arrays are recommended  6. performance wise collections are not
   to use.                                     recommended to use.
------------------------------------------------------------------------------------
List :
----
--> it is an interface and it is a sub interface of Collection.

--> if we want to represent a group of individual objects as a single entity where
    duplicates are allowed and insertion order is also preserved then we have to
    go for List collection interface.

Note:
 --> List interface and its implementation classes use index internally which 
     starts from '0'.

ArrayList :
---------
--> It is an implementation class of List interface.

--> If we want to store group of individual objects as a single entity where 
    duplicates are allowed and insertion order is preserved then use ArrayList.

    i. duplicates are allowed.
    ii. insertion order is preserved.
    iii. both homogeneous and heterogeneous objects are allowed.
    iv. null insertion is possible (any no. of times).

ex:
  ArrayList list = new ArrayList();

--> The above statement creates an empty ArrayList object with initial capacity
    as 10.

    -----------------------------------------------
      new capacity = current capacity * 3 / 2 + 1
    -----------------------------------------------


eclipse core java project structure
-----------------------------------
ProjectDirectory
|- src (.java files)
|- bin (.class files)


Vector :
------
--> it is another implementation class of List interface.

--> Vector is same as ArrayList except few differences.

--> If we want to store group of individual objects as a single entity where 
    duplicates are allowed and insertion order is preserved then use Vector.

    i. duplicates are allowed.
    ii. insertion order is preserved.
    iii. both homogeneous and heterogeneous objects are allowed.
    iv. null insertion is possible (any no. of times).

ex:
  Vector v = new Vector();

--> the above statement creates an empty vector object with initial capacity 
    as 10.

    -------------------------------------
     new capacity = 2 * current capacity 
    -------------------------------------

-----------------------------------------------------------------------------------
           ArrayList					Vector
-----------------------------------------------------------------------------------
1. it is not synchronized.                    1. it is synchronized.

2. it is not thread safe.                     2. it is thread safe.

3. performance is high.			      3. performance is low.

4. it is available from jdk 1.2v	      4. it is available from jdk 1.0v
   onwards hence it is non-legacy                onwards hence it is a legacy class.
   class.
------------------------------------------------------------------------------------
Cursors :
-------
What is a cursor?
--> A cursor is an object and a cursor is used to retrieve one by one element
    from a collection.

--> Using cursors (Enumeration, Iterator and ListIterator) we can iterate on
    collections to retrieve one by one element.

There are 3 cursors 

1. Enumeration
2. Iterator
3. ListIterator

Note:
 --> All above 3 cursors are interfaces available in java.util package.

Note:
 --> A cursor is an object of a class which is an implementation class of either
     Enumeration interface or Iterator interface or ListIterator interface.
   
 --> An interface implementation class object we can say indirectly interface 
     object.

Enumeration (interface)
|- boolean hasMoreElements(): it tests more elements are there or not
|- Object nextElement(): it returns an element

--> Enumeration is an interface, we cannot create object to an interface but we
    can create object to its implementation which is provided by sun microsystems
    itself and sun microsystems has provided a factory method which creates and
    returns the object of Enumeration interface implementation class.

Vector
|- Enumeration elements(): it is a factory method which creates and returns the
                           object of Enumeration interface implementation class.

disadvantages of Enumeration cursor :
-----------------------------------
1. Enumeration cursor is applicable only for legacy collection clases hence it is
   not a universal cursor.

2. Using Enumeration cursor we can perform only retrieve operation but not other
   operations like adding, removing and replacing.

--> To resolve the problems of Enumeration cursor sun microsystems has provided
    Iterator cursor.

advantages of Iterator cursor :
-----------------------------
1. Iterator cursor is applicable for all the collection classes (legacy and non-
   legacy) and hence Iterator is a universal cursor.

2. Using Iterator cursor we can not only perform retrieve operation but also one
   more additional operator called remove.

Iterator (interface)
|- boolean hasNext()
|- Object next()
|- void remove()

Note:
 --> sun microsystems has provided a factory method which creates and returns the
     object of Iterator interface implementation class.

 --> the factory method which creates and returns the object of Iterator interface
     implementation class is "iterator()".

     syntax:
         public Iterator iterator()

 --> the above factory method is available in all the collection classes.

     ex-1:
        ArrayList list = new ArrayList();
        Iterator itr = list.iterator();

     ex-2:
        Vector v = new Vector();
        Iterator itr = v.iterator();

disadvantages of Iterator cursor :
--------------------------------
1. Iterator cursor is a uni-directional cursor which means we can retrieve the 
   elements only in one direction that is by default forward.

2. Using Iterator cursor we can perform only 2 operations i.e., retrieve and remove
   but not add and replace operations.

--> to resolve the disadvantages of Iterator cursor sun microsystems has given
    ListIterator cursor.

advantages of ListIterator cursor :
---------------------------------
1. ListIterator cursor is a bi-directional cursor which means we can retrieve the
   elements not only in forward direction but also in backward direction.

2. Using ListIterator cursor apart from retrieve and remove operations we can also
   perform add and replace operations.

ListIterator (interface)
|- boolean hasNext()
|- boolean hasPrevious()
|- Object next()
|- Object previous()
|- void remove()
|- void add(Object element)
|- void set(int index, Object element)
|- int nextIndex()
|- int previousIndex()

--> we cannot create object to ListIterator interface but we can create object to
    its implementation class which is provided by sun microsystems.

--> sun microsystems has provided a factory method to create object to ListIterator
    interface implementation class :
        
    syntax:
        public ListIterator listIterator()

ex:
   ArrayList list = new ArrayList();

   ListIterator lt = list.listIterator();

disadvantage of ListIterator cursor :
-----------------------------------
i. ListIterato cursor is applicable only for List collection and hence it is not
   a universal cursor.

Generics :
--------
--> it is a feature which is added from jdk 1.5v onwards.

--> generics are used to make collections type safe.

advantages :
----------
i. it provides type safety
ii. it avoids type casting problem

syntax:
  ClassName<Type>   (or)   InterfaceName<Type>

generic class :
-------------
--> a class which stores a specific type of element.

type parameters in generics :
---------------------------
--> these are identifiers which are used to specify a generic type and
    type parameters act as place holders.

T	-	Class 
E	-	Element
K	-	Key
V	-	Value
N	-	Number

generic method :
--------------
--> a method which takes a specific type of elements.


ex:
  int[] arr = new int[5];

  arr[0] = 10;
  arr[1] = 20;
  arr[2] = 30;
  arr[3] = 2.5;  //c.e
  arr[4] = "hello";   //c.e

--> arrays are safe with respect to type or arrays are type safe.

  int[] arr = {1,2,3,4,5};

  int i = arr[0];
  System.out.println(i);  //1

--> at the time of accessing elements from an array we no need to perform
    any type casting.

ex:
  ArrayList list = new ArrayList();

  list.add(10);
  list.add("hello");
  list.add(2.5);
  list.add(true);

--> collections are not safe with respect to type or collections are not type safe.

  Integer i = (Integer)list.get(0);

--> at the time of accessing elements from a collection we need to perform
    type casting.

Note:
 --> Upto jdk 1.4v, all collection classes were non-generic and from
     jdk 1.5v onwards all collection classes sun microsystems has 
     re-written using generics.

LinkedList :
----------
--> It is a class and it is an implementation class of List interface.

--> LinkedList class internally implements Double LinkedList data structure.

--> If we want to store group of individual objects as a single entity where 
    duplicates are allowed and insertion order is preserved then use LinkedList.

    i. duplicates are allowed.
    ii. insertion order is preserved.
    iii. both homogeneous and heterogeneous objects are allowed.
    iv. null insertion is possible (any no. of times).

ex:
  LinkedList<Integer> ll = new LinkedList<Integer>();

--> the above statement creates an empty LinkedList object.

Stack :
-----
--> It is a sub class of Vector.

--> If we want to store group of individual objects as last in first out
    then go for Stack.

    i. duplicates are allowed.
    ii. insertion order is preserved.
    iii. both homogeneous and heterogeneous objects are allowed.
    iv. null insertion is possible (any no. of times).

ex:
  Stack<Integer> st = new Stack<Integer>();

--> the above statement creates an empty Stack object.  

Set :
---
--> If we want to represent a group of individual objects as a single entity
    where duplicates are not allowed and insertion order is not preserved
    then go for Set collection.

--> Set is an interface and a sub interface of Collection interface.

--> Set interface has several implementation classes
   
    i. HashSet  ii. LinkedHashSet  iii. TreeSet

HashSet :
-------
--> It is an implementation class of Set interface.

--> If we want to store a group of individual objects as a single entity where duplicates
    are not allowed and insertion order is also not preserved then go for HashSet.

    i. duplicates are not allowed.
    ii. insertion order is not preserved because elements (objects) are stored according
        to their hashcodes.
    iii. both homogeneous and heterogeneous objects are allowed.
    iv. null insertion is possible but only once.

ex:
  HashSet hs = new HashSet();

--> the above statement creates an empty hashset object with initial capacity as 16
    and default load factor as 0.75.

what is load factor?
--> load factor is a point after which crossing a new hashset object is created with
    double capacity. 

--> load factor must be between 0 and 1.

LinkedHashSet :
-------------
--> it is a sub class of HashSet and it is same as HashSet except few differences.

----------------------------------------------------------------------------------------
		HashSet					LinkedHashSet
----------------------------------------------------------------------------------------
1. insertion order is not preserved.	       1. insertion order is preserved.

2. it is built or implemented using hashtable  2. it is built or implemented using a
   data structure.                                combination of hashtable and linkedlist
                                                  data structure.

3. it is available from jdk 1.2v onwards.      3. it is available from jdk 1.4v onwards.
-----------------------------------------------------------------------------------------

SortedSet :
---------
--> it is a sub interface of Set interface and if we want to represent 
    a group of individual objects as a single entity where duplicates
    are not allowed, insertion order is not preserved and elements should
    be store with some sorting order then go for SortedSet.

NavigableSet :
------------
--> it is a sub interface or SortedSet interface and it provides several
    methods for navigation purpose.

TreeSet :
-------
--> if we want to store a group of individual objects as a single entity
    where duplicates are not allowed, insertion order is not preserved
    and objects are stored according to sorting order then go for TreeSet.

   i. duplicates are not allowed.
   ii. insertion order is not preserved because objects are stored
       according to sorting order.
   iii. only homogeneous objects are allowed if we store heterogeneous
        objects then TreeSet throws ClassCastException.
   iv. null insertion is possible only for empty TreeSet and after null
       if we store any other object then TreeSet throws NullPointerExcep-
       tion, for non-empty TreeSet null insertion is not allowed otherwise
       TreeSet throws NullPointerException.

ex:
   TreeSet ts = new TreeSet();

--> the above statement creates an empty TreeSet object sorted with
    natural order.


assignment: write a program on inner interfaces.

Map :
---
--> if we want to represent a group of individual objects as a key-value
    pair then we should go for Map.

--> here both key and value are objects.

--> duplicate keys are not allowed and duplicate values are allowed.

--> there is no relationship between Map interface and Collection interface.

--> Map is an interface and we cannot create object to Map interface but
    we can create object to Map interface implementation classes.

HashMap :
-------
--> it is an implementation class of Map interface.

--> if we want to store group of individual objects as key and value
    pair then we should go for HashMap.

    i. duplicates keys are not allowed but duplicate values are allowed.
    ii. insertion order is not preserved because keys are stored according
        to their hashcodes.
    iii. both homogeneous and heterogeneous objects are allowed for both
         key and value.
    iv. null insertion is allowed for keys only once and null insertion
        is allowed for values any number of times.

ex:
  HashMap map = new HashMap();

--> the above statement creates an empty HashMap object with initial
    capacity as 16 and default load factor as 0.75.

LinkedHashMap :
-------------
--> it is a sub class of HashMap class.

--> It is same as HashMap except few differences.

-------------------------------------------------------------------------
	HashMap					LinkedHashMap
-------------------------------------------------------------------------
1. insertion order is not preserved.    1. insertion order is preserved.

2. it is built or implemented using     2. it is built or implemented using
   hashtable data structure.               the combination of hashtable and
                                           linked list.

3. it is available from jdk 1.2v        3. it is available from jdk 1.4v
   onwards.                                 onwards.
--------------------------------------------------------------------------

Hashtable :
---------
--> it is another implementation class of Map interface.

--> it is same as HashMap except few differences.

-------------------------------------------------------------------------
	HashMap					Hashtable
-------------------------------------------------------------------------
1. it is not synchronized.            1. it is synchronized.

2. it is not thread safe.             2. it is thread safe.

3. performance is high.               3. performance is low.

4. null insertion is possible for     4. null insertion is not possible 
   both key and value.                   for both key and value otherwise
                                         jvm throws NullPointerException.

5. it is available from jdk 1.2v      5. it is available from jdk 1.0v
   onwards hence it is non-legacy        onwards hence it is legacy class.
   class.
-------------------------------------------------------------------------

WeakHashMap :
-----------
--> it is an implementation class of Map interface.

--> WeakHashMap is same as HashMap except one difference.

-----------------------------------------------------------------------------------
	    HashMap					    WeakHashMap
-----------------------------------------------------------------------------------
1. HashMap stores strong references of keys,  1. WeakHashMap stores weak references
   storing strong references of keys will not    of keys, stroring weak references
   allow garbage collector to remove that key    of keys will allow garbage collec-
   if the key is not having external reference   tor to remove that key if the key
   outside the HashMap object.                   is not having external reference 
                                                 outside the WeakHashMap object.
------------------------------------------------------------------------------------

IdentityHashMap :
---------------
--> it is an implementation class of Map interface.

--> it is same as HashMap except few differences.

-----------------------------------------------------------------------------------
	HashMap						IdentityHashMap
-----------------------------------------------------------------------------------
1. it is uses equals() internally to 	   1. it is uses == operator internally to
   compare keys which compares data.          compare keys which compares object
                                              references.

2. it is available from jdk 1.2v onwards.  2. it is available form jdk 1.4v onwards.
------------------------------------------------------------------------------------

TreeMap :
-------
--> It is an implementation class of NavigableMap interface which is a sub interface
    of SortedMap interface which is a sub interface of Map interface.

--> If we want to store group of individual objects as a key and value pair and
    with sorting order of keys then we should go for TreeMap.

    i. duplicate keys are not allowed but duplicate values are allowed.
    ii. insertion order is not preserved because keys are stored according to
        some sorting order.
    iii. keys must be homogeneous but values can be both homogeneous and hetero-
         geneous, if we store heterogeneous objects as keys then jvm throws
         ClassCastException.
    iv. null insertion is not possible for keys otherwise jvm throws NullPointer-
        Exception but values can be null any number of times.

ex:
  TreeMap tm = new TreeMap();

--> the above statement creates an empty TreeMap object sorted with natural sorting
    order.

Properties :
----------
--> It is a sub class of Hashtable which is an implementation class of Map interface.

--> Properties class object is used to represent a list of values in the form
    key and value where key is String type and value is also String type.

--> In Properties class object we can also store and retrieve key-value pairs by
    reading from properties file.

properties file :
---------------
--> a file which ends with .properties extension is called as properties file.

--> in properties file we store data in the following manner : 

    key=value

--> here key is String type and value is also String type.

here property means one key-value pair

properties means multiple key and value pairs


Date, Calendar, SimpleDateFormat


JEE (Advance Java)
---
jdbc
servlets
jsp

JDBC : (Java Database Connectivity)
----
What is jdbc?
--> jdbc is an api given by sun microsystems.

--> using jdbc api we can develop a java program to communicate or interact
    with database server.

--> communicating with database server means from java program sending sql queries
    to database server.

------------------------------------------------------------------------------------
AWT (Abstract Window Toolkit) --> Graphical User Interface stand-alone or desktop
Swings                                                applications

java.awt package
javax.swings package
-------------------------------------------------------------------------------------

--> before databases we use files to store and manage the data.

--> files are also called as flat files.

disadvantages of files :
----------------------
1. no security
2. data redundancy (duplicate data)
3. data inconsistency
4. limited data
5. no query language
6. data recovery
   etc

what is a database?
--> a place where we store and manage collection of data is called as database.

--> we can perform operations like retrieve, update, delete, insert on database.

dbms (database management system)
|- dbms is a software which allows to create and manage database.
|- in dbms the data is stored in files.

rdbms (relational database management system)
|- rdbms is also a software which is an advance version of dbms which also allows
   to create and manage database.
|- in rdbms the data is stored in the form tables and tables contains set of 
   columns.

------------------------------------
	     employee
------------------------------------
eno	ename	   gender    salary
------------------------------------
1        ravi       m        1000.0  ---->  record 
2        susan      f        2000.0
3        smith      m        3000.0
.
.
-----------------------------------

--> relational database management system (rdbms) softwares

    ex: oracle, mysql, sybase, db2, sql server, ms access etc

note:
 --> all rdbms softwares support one query language called as SQL.

SQL (Structure Query Language)   
|- it is a language or query language.
|- if we want to communicate with database software we use SQL.

SQL is divided into 5 sub types

1. DDL (Data definition language) 

   ex: CREATE, DROP, ALTER, TRUNCATE, RENAME  ---  ddl commands

2. DML (Data manipulation language)

   ex: INSERT, UPDATE, DELETE  ---  dml commands

3. DQL/DRL (Data query/retrieval language)
        
   ex: SELECT  ---  dql command

4. DCL (Data control language)

   ex: GRANT, REVOKE  ---  dcl commands

5. TCL (Transaction control language)

   ex: SAVEPOINT, COMMIT, ROLLBACK   ---  tcl commands

--> Database vendors develop and release database software in 2 formats

    1. enterprise edition  (commercial)
    2. express edition (open source)

oracle database express edition  --->   11g

mysql database enterprise edition (mysql workbench)  -->  5.7

--> once we download and install a database software we get 2 softwares

    1. database server software
    2. database client software
    
oracle database --> system (password)

mysql database --> root (password)


database commands (specific to database)

1. oracle database commands
   ex: connect, disconnect, describe, clear screen, exit, edit, show etc

Note:
  --> in oracle, to execute oracle database commands we no need to use ;

  --> to execute sql queries we must have to use ;

  --> in oracle database express edition there will be a admin user 
      whose name is "system".

  --> in mysql database the default user is root.

sql queries
|- insert, update, delete, select

-----------------------------------------------------------------------------------------
		JDBC					    ODBC
-----------------------------------------------------------------------------------------
1. Jdbc stands java database connectivity.    1. Odbc stands open database connectivity.

2. Released by sun micro system in 1997.      2. Released by microsoft in 1992.

3. implementation is provided in java         3. implementation is provided in c and c++
   language.                                     languages.

4. jdbc driver platform independent.          4. odbc driver platform dependent.

5. jdbc driver works on any operating         5. odbc driver works only on windows os.
   system.

6. jdbc driver is object oriented.            6. odbc driver is procedure oriented.

7. in jdbc driver performance is high.        7. in odbc driver performance is low.

8. jdbc driver we can use only for java       8. odbc driver we can use for any language.
   language.
-----------------------------------------------------------------------------------------

Jdbc 
|- api  (sun microsystems)
   |- predefined classes and interfaces
      |- package

--> Jdbc is an api and it is a part of JSE (Java Standard Edition).

--> Sun microsystems has released jdbc api in the form of 2 packages.

    1. java.sql  2. javax.sql

--> Important classes and interfaces of java.sql package :

    interfaces :
    ----------
    1. Driver
    2. Connection
    3. Statement
    4. PreparedStatement
    5. CallableStatement
    6. ResultSet
    7. DatabaseMetaData
    8. ResultSetMetaData
    9. ParameterMetaData

    classes :
    -------
    1. DriverManager
    2. Date
    3. Types

--> Important classes and interfaces of javax.sql package :

    interfaces :
    ----------
    1. DataSource

--> The following things are required when working jdbc :

    1. jdk 1.8
    2. database (rdbms) -- oracle, mysql etc
    3. jdbc api 4.x

------------------------------------------------------------------------------------------------------
--> The following things are required to developed jdbc application :
    
    1. database server
    2. jdbc driver
    3. java application with jdbc code 

Steps To Develop A Jdbc Application :
-----------------------------------
--> There are 5 steps

step-1: register the jdbc driver  (load the jdbc driver)

step-2: create the connection

step-3: create the statement

step-4: execute the sql query

step-5: close the connection


what is jdbc driver?
--> jdbc driver is a software component (class) which allows java applications 
    to communicate or interact with database server.

types of jdbc drivers :
---------------------
--> there are 4 types of jdbc drivers

1. Type-1  [jdbc-odbc bridge driver]
2. Type-2  [native api driver]
3. Type-3  [network protocol driver]
4. Type-4  [thin driver]

Note:
 --> We use Type-4 jdbc driver only.

 --> Type-4 jdbc driver is purely developed using java thats why it is also called
     as pure jdbc driver.

 --> Type-1, Type-2 and Type-3 jdbc drivers are not purely developed using java,
     some part is developed using c and c++ and some part is developed using java.

 --> Type-4 jdbc driver is the fastest jdbc driver but Type-1, Type-2 and Type-3
     are slow.

 --> In latest jdbc api version Type-1 jdbc driver is removed.

-----------------------------------------------------------------------------------
Oracle type-4 jdbc driver  -->  Oracle database


MySQL type-4 jdbc driver  -->  MySQL type-4 jdbc driver
 


Requirement-1: Develop a jdbc application to insert a record in database employee 
               table.

step-1: register the jdbc driver
------
   --> registering jdbc driver means creating jdbc driver class object and placing 
       with DriverManager.

   --> to place jdbc driver class object with DriverManager we have to use 
       registerDriver(Driver d) method of DriverManager class.
  
      ----------------------------------------------------
        Driver d = new oracle.jdbc.driver.OracleDriver();
        DriverManager.registerDriver(d);
      ----------------------------------------------------

java.sql
|- DriverManager 
   --> DriverManager is class and DriverManager is a basic service which manages
       set of jdbc drivers.

   --> DriverManager acts as an interface between user and driver, DriverManager
       keeps track of all the jdbc drivers which are registered and available and
       and handles establishing the connection between database server and appro-
       priate jdbc driver by selecting an appropriate jdbc driver.

what is driver class?
--> a class which provides the implementation to Driver interface is called as
    driver class.

--> every database vendor has provided implementation class to Driver interface 
    that class is called as driver class.

oracle database vendor
|- oracle driver class-->oracle.jdbc.driver.OracleDriver(oracle type-4 jdbc driver)

mysql database vendor
|- mysql driver class  --> com.jdbc.mysql.Driver (mysql type-4 jdbc driver)

Note:
 --> driver class is only called as jdbc driver.

step-2: create or establishes the connection 
------
    --> if java application wants to communicate or interact with database server,
        we must have to create or establish a connection between java application
        and database server.

java.sql
|- DriverManager
   |- static Connection getConnection(String url, String username, String password)

    ----------------------------------------------------------------------------------
      Connection con = DriverManager.getConnection                        ("jdbc:oracle:thin:@localhost:1521:xe", "bms", "welcome1");
    -------------------------------------------------------------------------------------

Note:
 --> con which is an object of a class which is an implementation class of 
     Connection interface represents the connection between java application 
     and database server.

 --> a connection is like a road between java application and database server.

 --> after connection is ready, we need a vehicle which can carry sql queries 
     from java application to database server over the connection which is like a 
     road, so a statement object acts like a vehicle to send sql queries from java 
     application to database server over the connection.

--> there are 3 types of statements in jdbc

    1. Statement
    2. PreparedStatement
    3. CallableStatement

--> all the above 3 statements are interfaces available in java.sql package.

step-3: create statement object
------
--> statement is an object and using statement object we can send sql queries from 
    java application to database server.

      ----------------------------------------
       Statement stmt = con.createStatement();
      ----------------------------------------

java.sql
|- Connection 
   |- public Statement createStatement() : it is a instance factory method which 
                                           creates and returns the object of 
                                           Statement interface implementation 
                                           class.


step-4: execute the query
------
--> sending sql query from java application to database server is called as
    execute the query.

 ---------------------------------------------------------------------------------
  int n = stmt.executeUpdate("insert into employee values(1,'ravi','m',1000.0)");
 ---------------------------------------------------------------------------------

--> in java, all sql queries are grouped into 2 categories

    1. non-select queries

       --> the queries which donot start with select keyword are called as
           non-select queries.

           ex: insert, update, delete 

       --> to execute non-select queries, sun microsystems has provided a method :

            syntax:
                public int executeUpdate(String query)

    2. select querues

       --> the queries which starts with select keyword are called as 
           select queries.

           ex: select

       --> to execute select queries, sun microsystems has provided a method :
 
           syntax:
               public ResultSet executeQuery(String query)

java.sql
|- Statement
   |- public int executeUpdate(String query)
   |- public ResultSet executeQuery(String query)

step-5: close the connection
------
   con.close();

java.sql
|- Connection
   |- void close() : it closes the connection and releases the system resource.
   

DML Operations using Statement :
------------------------------
1. insert
2. update
3. delete

DQL/DRL Operations Using Statement :
----------------------------------
1. select all columns and all records
2. select all columns and specific records
3. select specific columns and all records
4. select specific columns and specific records
5. select all columns and one record
6. select 1 column and 1 record

What is ResultSet?
--> a resultset is an object and a resultset represents a table of records.

--> ResultSet is an interface in java.sql package.

--> ResultSet is an object of an implementation class of ResultSet interface.

---------------------------------------------------------------------------------
     ResultSet rs = stmt.executeQuery("select * from employee");

--> executeQuery() method sends select query to database server, database server
    executes the query, returns result in the form table of records to execute-
    Query() method, executeQuery() creates ResultSet interface implementation 
    class, stores table of records in resultset object and returs resultset object.
-----------------------------------------------------------------------------------

Ways of registering jdbc driver :
-------------------------------
1st way: using registerDriver() method
-------

   Driver d = new oracle.jdbc.driver.OracleDriver();
   DriverManager.registerDriver(d);

--> here the jdbc driver is registered 2 times.

2nd way: load the jdbc driver class using forName()
-------
    
   Class.forName("oracle.jdbc.driver.OracleDriver");

--> once we load jdbc driver class the static block of jdbc driver class will
    be executed and jdbc driver is registered so loading jdbc driver class means
    registering the jdbc driver in jdbc.

3rd way: from jdbc api 4.x onwards, we no need to register the jdbc driver, the
-------  jdbc driver is registered automatically


---------------------------------------------------------------------------------
--> jdbc driver is nothing but driver class

--> jdbc driver class is an implementation class of Driver interface which is
    developed by database vendor.

--> all database vendors while developing jdbc driver class, inside jdbc driver 
    class they provided one static block and inside the static block database
    vendors have written the logic to register the jdbc driver already.

oracle jdbc driver class 
------------------------
package oracle.jdbc.driver;

public class OracleDriver implements Driver
{
    static
    {
       Driver d = new oracle.jdbc.driver.OracleDriver();
       DriverManager.registerDriver(d);
    }

    //other code
}

mysql jdbc driver class
-----------------------
package com.mysql.jdbc;

public class Driver implements Driver
{
    static
    {
       Driver d = new com.mysql.jdbc.Driver();
       DriverManager.registerDriver(d);
    }

    //other code
}


PreparedStatement :
-----------------
--> PreparedStatement is an object and PreparedStatement is used to send sql 
    queries with positional parameters from java application to database server.

--> PreparedStatement improves the performance of java application compare to
    Statement.

What are positional parameters?
--> Question marks ? are called as positional parameters.

--> Positional parameters act as place holders or parameters in an sql query.

--> Positional parameters have index which starts from 1.

--> When we use PreparedStatement to send sql query to the database server, we
    dont use values in sql queries, instead of values we use positional parameters
    in an sql query and we pass values to positional parameters later.

steps to develop jdbc application using PreparedStatement :
---------------------------------------------------------
step-1: load the jdbc driver (register the jdbc driver)

step-2: establish the connection

step-3: create PreparedStatement object by passing sql query with
        positional parameters

step-4: supply the values to all the positional parameters

step-5: execute sql query

step-6: close the connection

DML operations using PreparedStatement :
--------------------------------------
1. insert
2. update 
3. delete

--> To supply or set the values for positional parameters sun microsystems has
    provided setter methods in PreparedStatement.

PreparedStatement
|- public void setInt(int index, int value)
|- public void setFloat(int index, float value)
|- public void setDouble(int index, double value)
|- public void setString(int index, String value)
|- public void setDate(int index, Date value)
   etc

DQL/DRL operations using PreparedStatement :
------------------------------------------
1. select all columns and all records
2. select all columns and specific records
3. select specific columns and all records
4. select specific columns and specific records
5. select all columns and one record
6. select 1 column and 1 record

Requirement-1: develop a java program to read inputs from keyboard at runtime and
             store in database table using PreparedStatement.

Requirement-2: develop a java program to read inputs from keyboard at runtime and
             store in database table using Statement.
----------------------------------------------------------------------------------
differences between Statement and PreparedStatement :
---------------------------------------------------
1. PreparedStatement improves the performance of java application when compare 
   with Statement because in case of PreparedStatement the query is compiled 
   only once.

2. If we have dynamic values in an sql query it is recommended to use Prepared-
   Statement, if we use Statement we need to write complex string concatenation
   logic.

3. PreparedStatement prevents sql attacks or sql injection but not
   Statement.

when we PreparedStatement improves performance?
--> if we send same query multiple times to database server with
    different values then only PreparedStatement improves performance.

what happens when we send an sql query to database server?

step-1: database server checks the syntax of the query.

step-2: database server checks whether table is existing or not.

step-3: database server parses (converts) sql query into its understandable
        format.

step-4: database server generates internally algorithm to execute the sql query.

step-5: database server stores parsed sql query and algorithm in SGA memory.

step-6: database server executes the sql query using the algorithm and send
        output to the client.

first 5 steps are called query compilation

last step is called query execution

Note:
--> when we send an sql query to database server with bind variables then database
    server compiles the sql query only once and remembers and we send same query
    with bind variables multiple times then database server will not compile the
    query again as it remembers already so database server directly executes the
    sql query this is how bind variable improves the performance.

--> if we want to send same query multiple times with different
    values to database server then use PreparedStatement or else
    use Statement.

--> the positional parameters of PreparedStatement are internally
    converted into bind variables.

CallableStatement :
-----------------
--> CallableStatement is an object and CallableStatement is used
    to call database stored procedures from java application.

what are stored procedures?
--> stored procedures are prepared sql blocks.

--> stored procedures are used to write business logic and
    sql queries.

--> stored procedures are created and available in database server.

--> stored procedures are executed in database server.

--> stored procedures also improve performance of java application.

java.sql
|- Connection
   |- CallableStatement prepareCall(String query)

--------------------------------------------------------------------
CallableStatement cstmt = con.prepareCall("{call procedure_name}");
cstmt.execute
--------------------------------------------------------------------

Date, Calendar, SimpleDateFormat
inserting and retrieving dates
gui database client
batch processing
transaction management
databasemetadata
resultmetadata
parametermetadata

Assignment:
----------
        images
--------------------------
img_id   img_name   img
--------------------------
 1       tiger      ....
--------------------------

img_id --> number, int
img_name --> varchar2, varchar
img --> blob

d:\pictures\tiger.jpg

req: develop java program to insert an image in database table.

java.util
|- Date
|- Calendar

java.sql
|- Date

java.text
|- SimpleDateFormat


lob -> large objects
|- images, audio, video, text file

images, audio, video --> blob (binary long object)

text file --> clob (character long object)

4 gb
------------------------------------------------------------------
batch processing : 
----------------
--> grouping multiple queries in a batch and sending batch to
    the database server in one call is called as batch processing.

--> batch processing improves the performance as we are not 
    communicating with database server over the network multiple
    times.

transaction management
-----------------------
what is a transaction?
--> executing a sequence of steps as a single unit of work is     called as a transaction.
	
			(or)

--> executing group of operations to perform one task is called 
    as a transaction.

ex:
  transferring funds, depositing amount, withdrawing amount 

--> if all the operations are successfully completed then it is
    called as successful transaction.

--> if any operation in a transaction is failed to execute then
    it is called failure transaction.

--> in case of successful transaction we have to make the changes
    in the database permanent by doing commit and in case of 
    failure transaction incomplete changes will be made to the
    database which we have to take back by doing rollback.

Note:
 --> By default, in jdbc application jdbc driver manages the 
     transaction which means always jdbc driver does commit
     whether the transaction is successful or failure.

 --> It is never recommended to let jdbc driver to manage the
     transaction, it is always recommended to manage the tran-
     saction by the programmer.

 --> We need a seperate connection to perform a transaction,
     no two people should use same connection to perform
     multiple transaction.

types of transactions 
---------------------
--> there are 2 types of transaction

1. local transaction

   --> if we perform a transaction with one resource (database)
       then it is called as local transaction.

2. global transaction

   --> if we perform a transaction with two resources (databases)
       then it is called as global transaction.

Note:
 --> jdbc api supports only local transaction.

 --> to work with global transaction sun microsystems has given
     JTA api (Java Transaction Api).

 --> transaction management logic we need to write only for 
     dml queries.

steps for managing the transaction
----------------------------------
1. try-catch-finally
2. set auto commit as false (con.setAtCommit(false))
3. create flag variable
4. in finally call commit() or rollback() base on flag

----------------------------------------------------------------
Servlets :
--------
what is servlet?
--> servlet is an api given by sun microsystems to develop dynamic
    web applications.

--> servlet is also called as technology.

what is a web application?
--> web application runs on server and web application is a 
    multi users application.

--> a web application contains web pages.

what is web page?
--> the pages which are sent by server to the client over the
    network and which are received by the client and display 
    to the user are called as web pages.

--> there are 2 types of web pages

    1. static web pages

       --> the web pages whose contents are fixed which will never change are 
           called as static web pages.

           ex: html pages

    2. dynamic web pages

       --> the web pages whose contents are not fixed and which will change
           frequently are called as dynamic web pages.

           ex: servlet and jsp


Http :
----
--> Http stands for Hyper Text Transfer Protocol.

--> protocol means set of rules.

--> Http is a protocol given by W3C Organisation as an open specification.

--> W3C organisation has released http protocol in 2 versions

    1. Http 1.0  (initial version)

    2. Http 1.1  (current version)

--> Http protocol is having two parts

    1. Http Request
    2. Http Response   

what is get request?
--> if client sends the request to server using http method as GET then it is
    called get request.

what is post request?
--> if client sends the request to server using http method as POST then it is
    called post request.

-----------------------------------------------------------------------------------
		GET					POST
-----------------------------------------------------------------------------------
1. if client wants to get or access any   1. if client wants to send or post any
   information available in server then     information to the server then client
   client should send GET request.          should send POST request.

2. GET method is read-only.               2. POST method is write or update
                                            operation.

3. in GET request the form data will      3. In POST request the form data will be
   be appended to url as query string       placed in request body of http request
   parameters and sends to the server.      and sends to the server.

4. GET is not secure.                     4. POST is secure.

5. Using GET we can send only             5. Using POST we can send characters
   characters but we cannot send binary     and binary data also.
   data like images etc.

6. Using GET we can send small amount of  6. Using POST we can send large amount 
   data.                                     of data.

7. GET is idemponent.                     7. POST is non-idemponent.

8. There different ways are there to      8. There is only one way to send POST
   send GET request :                       request :

   i. by typing url and pressing enter      i. if we submit the form by using an
      GET request goes to server.              attribute method="POST" then POST
   ii. whenever we click on a hyperlink        request goes to server.
       or anchor tag GET request goes
       to server.
   iii. if we submit a form without 
        using method attribute then
        GET request goes to server.
   iv. if we submit a form using method
       attribute as GET then GET request
       goes to server. 
----------------------------------------------------------------------------------------

--> a client (browser) can send request to server in following ways :

    1. by typing url and pressing enter
    2. by clicking a hyperlink
    3. by clicking a button

--> servlet is an api released by sun microsystems in the form of 2 packages 

    1. javax.servlet
    2. javax.servlet.http

--> servlet api is a part of JEE.

--> the most important classes and interfaces of javax.servlet package

    interfaces :
    ----------
    1. Servlet
    2. ServletRequest
    3. ServletResponse
    4. ServletConfig
    5. ServletContext
    6. RequestDispatcher

    classes :
    -------
    1. GenericServlet

--> the most important classes and interfaces of javax.servlet.http package

    interfaces :
    ----------
    1. HttpServletRequest
    2. HttpServletResponse
    3. HttpSession

    classes :
    -------
    1. HttpServlet
    2. Cookie

--> servlet is a java which which provides implementation to Servlet interface 
    and servlet runs inside the web server.

-----------------------------------------------------------------------------------
--> to develop servlets we need following things :
 
    1. web server (apache tomcat)
    2. client program (browser)

Note:
 --> in our class, same machine will act as both client machine and server machine
     so we need to install web server and client program on same machine.

procedure to develop web application :
------------------------------------
step-1: create a directory whose name should project name.

step-2: inside project directory creater another directory whose name 
        must be WEB-INF.

step-3: inside WEB-INF directory create multiple directories like classes 
        and lib.

step-4: inside WEB-INF directory create an xml file whose name must be 
        web.xml.

step-5: in web.xml file create a root tag as <web-app></web-app>.

step-6: place all the class files (.class files) in classes directory if
        any available, place all the jar files in lib directory if any
        available and place all html and jsp pages inside project direc-
        tory outside WEB-INF directory if any available.

step-7: start the server (web server) and deploy the project (web appli-
        cation directory).

step-8: open client (browser), type url to send the request to server
        (web server) to access web application.

        ----------------------------------------------
          http://localhost:8081/FirstWeb/welcome.html
        ----------------------------------------------

Note:
 --> After we develop a web application we have to place web application
     inside the server (web server).

 --> Placing a web application inside the server means placing the web
     application inside deployment directory of the server.

 --> In every web server we have deployment directory where we place
     web application.

 --> In apache tomcat server the deployment directory name is "webapps".

 --> In weblogic server the deployment directory name is "autoDeploy".

what is deployment?
--> placing the project directory inside the server deployment directory
    is called as deployment.

WEB-INF :
-------
--> in web application WEB-INF directory is a protected directory, any
    thing which is placed inside the WEB-INF directory only web server
    can access it but not the client (browser).

classes :
-------
--> all the class files (.class files) we must have to place in classes
    directory, servlet container searches for .class files in classes 
    directory so classes directory is called as classpath in web applica-
    tion.

lib :
---
--> all the jar files we must have to place in lib directory, server
    searches for .class files in lib directory's jar files also.

web.xml :
-------
--> web.xml is also called as deployment descriptor.

--> we provide the information of servlets in web.xml and servlet 
    container reads the information which is there in web.xml.

javax.servlet
|- Servlet (interface)
   |- 5 abstract methods
        1. void init(ServletConfig config)
        2. void service(ServletRequest req, ServletResponse resp)
        3. void destroy()
        4. ServletConfig getServletConfig()
        5. String getServletInfo()

procedure to develop first servlet using Servlet interface :
----------------------------------------------------------
step-1: develop a class which implements Servlet interface.

step-2: create ServletConfig reference variable as an instance variable.

step-3: write a zero parameter constructor.

step-4: override and provide the implementation to all the 5 abstract
        methods of an interface.

step-5: compile the servlet class by setting classpath of servlet-api.jar.

step-6: place the class file (.class file) in classes directory.

step-7: provide the information of servlet in web.xml this is called
        configuring servlet in web.xml.

-----------------------------------------------
<web-app>   
  <servlet> 
     <servlet-name>firstservlet</servlet-name>
     <servlet-class>FirstServlet</servlet-class>
  </servlet>

  <servlet-mapping>
     <servlet-name>firstservlet</servlet-name>
     <url-pattern>/first</url-pattern>
  </servlet-mapping>
</web-app>
------------------------------------------------

Note:
 --> to configure a servlet in web.xml, sun microsystems has provided
     some predefined xml tags.

-----> <web-app> tag represents web application

 -----> <servlet> tag represents servlet
    
step-8: start the server and deploy the project (web application directory)

step-9: open the client (browser), send the request to server to access the servlet
        using a url

         http://localhost:8081/FirstWeb/first

--------------------------------------------------------------------------------------
--> when client has sent the request to server for the first time to access the servlet
    we have observed following things :

    i. servlet container is creating servlet object
    ii. after servlet object is created init() method is called immediately
    iii. after init() method service() method is called

--> when client sends the request to server to access the servlet for second onwards
    servlet container is calling only service() method.

--> servlet container is creating servlet object only once when client sends the 
    request for the first time.

--> servlet container calls destroy() method before servlet object is removed or 
    destroyed.

when servlet container removes or destroy servlet object?
--> whenenver we undeploy the project servlet container automatically removes servlet
    object and before removing servlet object servlet container calls destroy().

what is undeployment?
--> removing the project (web application directory) from server deployment directory
    is called as undeployment.

Note:
 --> servlet container creates servlet object only once when client sends the
     request for the first time.

 --> only one servlet object will be created inside the web server.

when servlet container calls init() method?
--> servlet container calls init() method only once immediately
    after servlet object is created.

when servlet container calls service() method?
--> servlet container calls service() method for every client
    request.

when servlet container calls destroy() method?
--> servlet container calls destroy() method only once before
    destroying or removing servlet object from the web servlet.

----------------------------------------------------------------------
public class FirstServlet implements Servlet
{
    private ServletConfig config;

    public FirstServlet() {
       System.out.println("FirstServlet object is created...");
    }

    public void init(ServletConfig config) 
    {
       this.config = config;
       System.out.println("init() method called...");
    }

    public void service(ServletRequest request, ServletResponse response)
    {
        System.out.println("service() method called...");
    }

    public void destroy()
    {
       config = null;
       System.out.println("destroy() method called...");
    }

    public ServletConfig getServletConfig() 
    {
       System.out.println("getServletConfig() method called...");
       return config;
    }

    public String getServletInfo()
    {
       System.out.println("getServletInfo() method called...");
       return "first servlet example";
    }
}

--> if we develop a servlet using Servlet interface we need to write lot of code.

--> to resolve this problem sun microsystems has created one implementation to
    Servlet interface called as GenericServlet and insider GenericServlet sun
    microsystem has provided implementation to all the 4 abstract methods except
    service() method.


public abstract class GenericServlet implements Servlet
{
    private ServletConfig config;

    public GenerictServlet() {
    }

    public void init(ServletConfig config) 
    {
       this.config = config;
       System.out.println("init() method called...");
    }

    public void destroy()
    {
       config = null;
       System.out.println("destroy() method called...");
    }

    public ServletConfig getServletConfig() 
    {
       System.out.println("getServletConfig() method called...");
       return config;
    }

    public String getServletInfo()
    {
       System.out.println("getServletInfo() method called...");
       return null;
    }
}

--> from now onwards we no need to develop servlet using Servlet interface, we
    can use GenericServlet to develop a servlet and we need to override only
    service() method and rest of the code will be inherited from GenericServlet.

public class FirstServlet extends GenericServlet
{
   public void service(request, response)
   {     
   }
}

--> instead of develop a servlet using GenericServlet, sun microsystems has
    created a sub class to GenericServlet whose name is HttpServlet and inside
    HttpServlet class sun microsystem has overridde service() method and provided
    implementation.

public abstract class HttpServlet extends GenericServlet
{
   public void service(request, response)
   {     
   }
}

--> HttpSerlvet class is having 0 abstract methods and still sun microsystems
    has declared HttpServlet class abstract, because they dont want any to 
    create object to HttpServlet.

--> From now onwards we need to develop a servlet by extending HttpServlet class
    and whatever the method we want in our servlet we have to override.

Note:
 --> as servlet is running at server side on server machine and inside 
     the web server so if we use System.out.println() in servlets then
     System.out.println() will display output to server console but not
     to the client.

 --> if we want to send any output to the client then we have to write 
     the data to response object by using PrintWriter.
req-1: develop a servlet using HttpServlet to display 3 lines
       of output to the client.

HttpServletResponse
|- public void setContentType(String mimeType)
   --> it sets the content type of the response being sent to the client

req-2: develop a servlet using HttpServlet to display current system date and 
       time in the below format 

       current system date and time : 29/April/2021 06:00:30 PM


req-3: develop a servlet using HttpServlet to retrieve all the records from database
       table and display to the client (browser) in tabular form.


eclipse web application directory structure :
-------------------------------------------
ProjectFolder
|- Java Resources
   |- src 
|- WebContent
   |- WEB-INF
      |- lib
      |- web.xml
|- build
   |- classes  (.class files)

apache tomcat software
|- it comes up in 2 versions
   i. installer
   ii. zip file

Note:
 --> when we are working with ide we must have to use zip file for
     web servers.

--> in servlets web.xml (deployment descriptor) is a configuration file

servlets, jsp, html etc --> web resources

--> in servlets it is always recommended to display output at client side but not 
    server side.

--> printStackTrace() method always displays exceptions at server side only.

--> in servlets to display exceptions at client side we have to use sendError() method.

HttpServletResponse
|- public void sendError(int statusCode, String statusMessage) : it sends the error
   response to the client with the specified status code and status message.

Note:
 --> we must have to call sendError() method from catch block only.

what is hard coding?
--> fixing the values in the program is called as hard-coding.

--> it is never recommended to hard code values in the program, it is always
    recommended to soft-code the values in the program.

how to remove hard coding in servlets?
--> to remove hard coding in servlets we use

    1. ServletContext
    2. ServletConfig
    3. properties file


Servlet
|- GenericServlet  (public ServletContext getServletContext())
   |- HttpServlet
      |- ReadServletConfigServlet


form based applications :
-----------------------

when servlet container creates servlet object?

1st way:
-------
   when client sends the request to server to access the servlet for the first
   time servlet container creates servlet object.

2nd way:
-------
   when we use a tag called as <load-on-startup> in web.xml then at the time
   of deploying the project itself servlet container creates servlet object 
   calls init() method.

<load-on-startup> tag
---------------------
--> if we use <load-on-startup> tag in web.xml for a servlet then at time of
    deploying the project (web application) itself servlet container creates
    servlet object and calls init() method.

--> <load-on-startup> tag takes a positive value as input and it should be 
    between 1 to 10.

--> <load-on-startup> tag is a child tag of <servlet> tag.

-----------------------------------------------------------------------

<servlet>
     <servlet-name>testservlet1</servlet-name>
     <servlet-class>com.losw.servlet.TestServlet1</servlet-class>
     
     <load-on-startup>1</load-on-startup>
  </servlet>

<servlet>
     <servlet-name>testservlet2</servlet-name>
     <servlet-class>com.losw.servlet.TestServlet2</servlet-class>
     
     <load-on-startup>2</load-on-startup>
  </servlet>

------------------------------------------------------------------------

doGet() and doPost() :
--------------------
javax.servlet.http
|- HttpServlet
   |- void service(request, response)
   |- void doGet(request, response)
   |- void doPost(request, response)

--> doGet() method supports only get request but post request.

--> doPost() method supports only post request but not get request.

--> service() method supports both get and post request.

servlet life cycle :
------------------
--> servlet life cycle can be defined as the entire process of its creation
    and till its destruction.

--> servlet container manages the servlet life cycle.

--> in servlet life cycle, servlet container first loads servlet into jvm's 
    memory, creates servlet object, after creating servlet object servlet 
    container immediately calls init() method to initialize the servlet only
    once, after init() method servlet container calls service() method for
    every client request, finally servlet container removes servlet object
    and before removing servlet object servlet container calls destroy() method.

--> during servlet life cycle, servlet container calls init(), service() and 
    destroy() methods so these methods are called as servlet life cycle methods.

--> servlet container calls init() method only once immediately after servlet
    object is created.

--> servlet container calls service() method for every client request.

--> servlet container calls destroy() method only once before removing or 
    destroying servlet object from the web server.

--> if we want to execute any code which has to be executed only once immediately
    after servlet object is created such code we need to write in init() method.

--> if we want to execute any code which has to be executed every time whenever
    a client sends a request such code we need to write in service().

--> if we want to execute any code which has to be executed only once before
    servlet object is destroyed or removed such code we need to write in destroy()
    method.


jsp : (java server pages)
---
--> jsp is a technology given by sun microsystems to develop dynamic web applications.

--> we use servlet as well as jsp to develop dynamic web applications.

advantages of jsp over servlet :
------------------------------
1. jsp improves the productivity of web applications.

2. to develop jsp we no need to be aware of java code because jsp uses tags
   (jsp elements).

3. using jsp we can seperate presentation logic from business logic.

disadvantages of jsp :
--------------------
1. jsp takes more time when client sends the request for the first time and that
   to the time jsp takes is in milli seconds only.

--> as jsp takes time when client sends the request for the first which is in 
    milli seconds so we dont consider this as disadvantage and if we want we
    can resolve this by using <load-on-startup> tag.

--> every jsp must ends with .jsp extension.

--> we have to place jsp inside the project directory and outside the WEB-INF directory.

--> as jsp is placed outside the WEB-INF directory thats why we no need to 
    configure the jsp into web.xml file, a client can access the jsp directly
    by its name.

--> to develop a jsp we no need to restart the server, if server is running
    meanwhile we can develop jsp.

--> jsp takes more time only for the first time but jsp will not take more time
    when client sends request second time onwards.

-----------------------------------------------------------------------------------------------------
--> In apache tomcat web server we have a cache directory called as "work".

--> In cache directory work auto translated servlet will be created and available by servlet container.

Note:
 --> servlet container translates a jsp into a servlet internally and that servlet
     is called as auto generated servlet.

 --> inside auto generated servlet, servlet container creates jsp life cycle
     methods as _jspInit(), _jspService() and _jspDestroy().

 --> a jsp is nothing but a servlet only.
 
-----------------------------------------------------------------------------------
--> To develop jsp we must have to use jsp elements.

--> Jsp elements are like tags.

jsp elements :
------------
--> There are total 8 jsp elements

1. Template Text
2. Scriplet
3. Jsp declaration
4. Jsp expression
5. Jsp directives
6. Jsp action tags
7. Jsp custom tags
8. EL-Expression 

Template Text :
-------------
--> In a jsp everything which is not a jsp element is called as template text.

--> Template text is sent directly to the client.

Note:
  --> servlet container converts template text into some java code and places the 
      java code inside _jspService() of auto translated servlet at the time of 
      translating a jsp into a servlet.

--------------------------------
this is line-1<br/>    --->   template text

this is line-2<br/>    --->   template text

this is line-3         --->   template text
--------one.jsp-----------------

Note:
 --> writing anything in jsp means writing in auto translated servlet.

Scriplet :
--------
--> scriplet is a jsp element and it is used to write java code in jsp.

syntax:
  <%
     //java code
  %>

Note:
 --> at the time of translating a jsp into a servlet, sevlet container takes
     the java code of scriplet and places inside _jspService() method of auto
     translated servlet.

 --> scriplet code is local code because it is place inside _jspService() method.

Jsp declaration :
---------------
--> Jsp declaration is a jsp element and it is used to write instance variables,
    static variables, instance methods and static methods in jsp.

syntax:
  <%!
     //instance variables
     //static variables
     //instance methods
     //static methods
  %>

Note:
 --> at the time of translating a jsp into a servlet, sevlet container takes
     the code of jsp declaration and places auto translated servlet class.

 --> servlet container calls only jsp life cycle methods i.e., _jspInit(),
     _jspService() and _jspDestroy() but servlet container will not call
     our methods.

 --> if we want servlet container to call our methods then we have to explicitly
     call our methods from any one of the jsp life cycle method.

Note:
 --> We cannot access jsp implicit objects in jsp declaration.

 --> We can access jsp implicit objects in scriplet.

Jsp Implicit Objects :
--------------------
--> At the time of translating a jsp into a servlet, servlet container creates some 
    objects inside _jspService() method of auto translated servlet such objects are 
    called as jsp implicit objects.

--> All jsp implicit objects we can use directly inside the jsp without declaration.

--> There are total 9 jsp implicit objects 

    1. request
    2. response
    3. out
    4. session
    5. application
    6. config
    7. page
    8. pageContext
    9. exception  (it is not created by default)


1. request :
   -------
   --> it is an implicit object of jsp and it can be used directly inside the
       jsp without declaration.

           request --> javax.servlet.http.HttpServletRequest

   --> request is an object of HttpServletRequest.

requirement-1: develop a jsp to display context root or context path, protocol,
               method, url, uri, request headers information to the client.

requirement-2: develop a form and jsp, capture the form data in jsp and display
               to the client. 

2. response :
   --------
--> it is an implicit object of jsp and it can be used directly inside the
    jsp without declaration.

              response --> javax.servlet.http.HttpServletResponse

--> response is an object of HttpServletResponse.

Requirement: develop a jsp to send error response to the client.

3. out :
   ---
--> it is an implicit object of jsp and it can be used directly inside the
    jsp without declaration.

        out --> javax.servlet.jsp.JspWriter

--> out is an object of JspWriter.
-----------------------------------------------------------------------
--> jsp is an api released by sun microsystems in the form of of one
    package.

    1. javax.servlet.jsp

javax.servlet.jsp
|- JspWriter : it is a class.

--> JspWriter is same as PrintWriter class but JspWriter has an internal
    buffer whose size is 8kb.
-----------------------------------------------------------------------         
4. session :
   -------
--> it is an implicit object of jsp and it can be used directly inside the
    jsp without declaration.
   
           session --> javax.servlet.http.HttpSession

--> session is an object of HttpSession.

--> by default in jsp session object is created.

--> if we want to tell servlet container at the time of translating a jsp
    into a servlet dont create session object in auto translated servlet
    then use : <%@page session="false"%>.

class A
{
   void m1()
   {
      int num = 100;
      m2(num);
   }

   void m2(int num)
   {
       Sopln(num);  //100
   }
}

5. application :
   -----------
--> it is an implicit object of jsp and it can be used directly inside the
    jsp without declaration.

          application --> javax.servlet.ServletContext

--> application is an object of ServletContext.

--> as ServletContext object is created and available in the web server so
    using ServletContext object we can get the information of web server
    and what is available in web server those information also.

6. config :
   ------
--> it is an implicit object of jsp and it can be used directly inside the
    jsp without declaration.

         config --> javax.servlet.ServletConfig

--> using ServletConfig object we can get ServletContext object, servlet name and
    we can also store data into ServletConfig object using <init-param> tag.

7. page :
   ----
--> it is an implicit object of jsp and it can be used directly inside the
    jsp without declaration.

             page --> java.lang.Object

--> it is a synonym for this keyword.

--> this keyword represent current class object so page is a synonym for this keyword
    which page hold current auto translated servlet object.

--> using page implicit object we can call auto translated servlet methods.

class A
{
   void m1()
   {
   }

   void m2()
   {
      Object page = this;

      ((A)(page)).m1();
   }
}

8. pageContext :
   -----------
--> it is an implicit object of jsp and it can be used directly inside the
    jsp without declaration.

          pageContext --> javax.servlet.jsp.PageContext

--> pageContext is an object of PageContext.

--> pageContext object represents entire jsp page.

--> using pageContext object we can get other implicit objects of jsp.

--> using pageContext object we can store the data into scope variables.

9. exception :
   ---------
--> it is an implicit object of jsp and it can be used directly inside the
    jsp without declaration.

            exception --> java.lang.Throwable

--> exception is an object of Throwable.

--> by default in jsp exception implicit object will not be created, servlet
    container creates exception implicit object in case of error page.

-----------------------------------------------------------------------------------
Jsp Expression :
--------------
--> Jsp expression is a jsp element and it simplifies the use of java expression.

syntax:
   <%=java-expression%>

what is java expression?
i. displaying the value of a variable to the client is called as java expression.

ii. performing arithmetic and relational operations on variables and displaying
    the result is called as java expression.

iii. creating object and display object is called as java expression.

iv. calling a method on an object and displaying the return value of a method 
    is called as java expression.

Note:
 --> jsp expression servlet container converts into out.println().

Jsp directives :
--------------
--> Jsp directives are jsp element and jsp directives are used to give some
    instructions to servlet container and based on that instructions servlet
    container perform some operations.

--> There are 3 jsp directives 

    i. page 
    ii. include
    iii. taglib

syntax:
  <%@directive-name attributes%>

page : (jsp page directive)
----
syntax:
  <%@page attributes%>

attributes of jsp page directive
--------------------------------
i. session
ii. ContentType
iii. import
iv. errorPage
v. isErrorPage
vi. isELIgnored

jsp include directive :
---------------------
--> it is used to include the contents of one jsp into another jsp.

syntax:
   <%@include attribute%>

attribute of include directive :
------------------------------
i. file

Exception Hanling in jsp :
------------------------
--> to handle exception in jsp we use isErrorPage and errorPage attributes of
    jsp page directive.

Note:
 --> in jsp all exceptions are displayed at client side.
 
 --> a jsp which contains error message is called as error page and in all
     error pages we have to create exception implicit object of jsp to hold
     exception object using isErrorPage attribute of page directive.

RequestDispatcher :
-----------------
--> RequestDispatcher is an object and it is used to dispatch the request from
    one resource to another resource.

--> the resource can be a servlet or jsp or html.

--> we can dispatch the request from servlet to servlet, servlet to jsp, 
    servlet to html, jsp to jsp and jsp to html.

javax.servlet
|- RequestDispatcher (I)
   |- void include(ServletRequest, ServletResponse)
   |- void forward(ServletRequest, ServletResponse)

HttpServletRequest
|- public RequestDispatcher getRequestDispatcher(String path)

requirement-1: forward the request from one servlet to another servlet.

requirement-2: forward the request from servlet to jsp.

requirement-3: forward the request from jsp to jsp.

requirement-4: forward the request from jsp to html.

Java Beans :
----------
what is a java bean?
--> a class which is developed using java beans specifications (rules) given
    by sun microsystems is called as java bean, so java bean is a java class
    which is developed using some rules.

--> java bean is a class whose object can be used to hold data.

--> java bean is a reusability component.

rule-1: java bean must implements Serializable marker interface.

rule-2: all the properties of java beans must be private.

rule-3: a java bean must have a zero argument constructor.

rule-4: a java bean has setters and getters.

ex:
   public class EmployeeBean   //here Bean word is not mandatory
   {
       private int eno;
       private String ename;
       private double salary;
   
       public EmployeeBean() {
       }

       public void setEno(int eno) {
          this.eno = eno;
       }

       public int getEno() {
          return eno;
       }

       public void setEname(String ename) {
          this.ename = ename;
       }
 
       public String getEname() {
         return ename;
       }

       public void setSalary(double salary) {
         this.salary = salary;
       }

       public double getSalary() {
          return salary; 
       }
   }

types of logics :
---------------
1. business logic
2. presentation logic
3. persistence logic (data access logic)

--> the logic which is written to satisfy the business rules given by business
    client is called as business logic. 

    ex: addition of two numbers, calculating interest, calculating discount etc.

--> the logic which is written to display the output to the client is called as
    presentation logic.

    ex: html, out.println() 

--> the logic which is written to interact with the database server is called
    as persistence logic.

    ex: jdbc code, hibernate code

Note:
 --> It is always recommended to seperate business logic, presentation logic and
     persistence logic because maitenance of application becomes easy.

 --> Whenever we develop a web application, we must have to use minimum of 3 
     components.

     1. Controller Component  (servlet)
     2. Model Component  (Java bean)
     3. View Component  (html or jsp)

 --> Controller is responsible to receive the request from client (browser), 
     captures the request data, create model object, call methods of model object
     and dispatch the request to view component.

 --> Model component is used to hold the state (data).

 --> View component is responsible to display output to the client (browser).

Note:
 --> a servlet acts as a controller component, a jsp or html acts as a view 
     component and java bean acts as model component.

scope variables :
---------------
--> the availability of an object from one place of an application is defined
    as scope of that object.

--> in jsp we have 4 scope variables and every scope variable has a different scope.

    1. page scope
    2. request scope
    3. session scope
    4. application scope

--> actually all the scope variables are objects in jsp.

--> in servlet we have 3 scope varialbes 

    1. request scope
    2. session scope
    3. application scope

Note:  we can store data in scope variables.

page scope :
----------
--> if we store the data into page scope then we can access that data in the
    same or current jsp page.

request scope :
-------------
--> if we store the data into request scope then we can access the data in 
    all the pages which serves with same request.

request-1 (data-1)  --->  one.jsp  -->  dispatch request-1 (data-1) --> two.jsp

session scope :
-------------
--> if we store the data into session scope then we can access the data in
    all the pages which are belonged to same session.

logged in 
  |
 session object is created (data-1)

 one.jsp, two.jsp, three.jsp  (data-1)

loggged out
  |
session object is removed

application scope :
-----------------
--> if we store the data into application scope then all the servlets and jsp
    of an application can access the data until the project is undeployed.

Note:
 --> to store the data into scope variables we use setAttribute(String name, Object value).

 --> to remove the data from scope variables we use removeAttribute(String name).

 --> to get the data from scope variables we use getAttribute(String name).

public void setAttribute(String name, Object value)
public Object getAttribute(String name)
public void removeAttribute(String name)

jsp action tags :
---------------
--> in web applications a jsp acts as view and jsp is used to write presentation
    logic so it is not recommended to write java code in jsp.

--> it is always recommended to remove java code from jsp.

--> to remove java code from jsp we use jsp action tags.

the following are the jsp action tags
-------------------------------------
i. <jsp:include>
ii. <jsp:forward>
iii. <jsp:setProperty>
iv. <jsp:getProperty>
iv. <jsp:useBean>

Note:
  --> <jsp:include> and <jsp:forward> action tags are same as RequestDispatcher's
      include() and forward() methods.

--> using jsp action tags we cannot remove complete java code from jsp, to remove
    complete java code from jsp we have to use jsp custom tags.

--> using jsp custom tags we can remove complete java code from jsp.

jsp custom tags : creating our own user defined tags is called as jsp custom tags.
---------------

--> instead of creating our own userdefined tags to remove complete java code
    from jsp, already apache software foundation (ASF) organisation has 
    created custom tags which are used frequently in an application and apache
    given custom tags in the form jstl tag library.

what is jstl?
--> jstl stands for jsp standard tag library and jstl is a tag library which 
    contains several tags, which are used to remove java code completely 
    from jsp and which is develop by apache people.

--> jstl has 5 sub tag libraries

    1. core tag library
    2. xml tag library
    3. format tag library
    4. sql tag library
    5. function tag library

--> the most important jstl tag library is jstl core tag library.

--> for every tag library apache people has given one uri and prefix.

note:
 --> for every tag there will be one class is developed which contains the
     actual logic or code such class is called as tag handler class.

procedure to use jstl tag library :
---------------------------------
step-1: download the jstl jars
step-2: place all the jstl jars in project lib directory
step-3: import the jstl tag library in jsp using taglib directive.
step-4: type control space to use the jstl tags

jsp taglib directive : it is used to import a tag library in jsp.
--------------------
 syntax:
   <%@taglib uri="" prefix=""%>

--> javax.servlet.jsp.jstl-1.2.1.jar
--> javax.servlet.jsp.jstl-api-1.2.1.jar

Note:
 --> It is never recommended to use jstl tags to display static output, it is always
     recommended to use jstl tags to display dynamic output and to work dynamic
     output we have to use EL-Expression in jstl.

EL-Expression
-------------
--> it is a jsp element and it is used to deal with scope variables.

--> if we have any value in any scope variable, if we want to read the value
    from a scope variable and display to the client we use EL-Expression.

syntax:
  ${expression}








